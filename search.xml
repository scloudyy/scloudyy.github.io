<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[强联通分量]]></title>
    <url>%2Fposts%2F698a5304%2F</url>
    <content type="text"><![CDATA[强联通分量 有向图 \(G=(V, E)\) 的一个强连通分量是一个最大的顶点子集\(C​\)，\(C​\)中每对顶点\((s, t)​\)都是互达的。无向图只要节点相连就是互达的，只要使用BFS就行 Tarjan 对graph进行dfs，节点按访问顺序入栈。但节点v访问结束所有子节点后，检测该节点能否到达栈中任意更早入栈的节点：如果能，说明该节点能够访问到祖先，是SCC中的节点，只是不是root，将该节点保留在栈中；如果不能，说明该节点是强连通域的root（是否为root完全看访问顺序），则将该节点以及比该节点更晚入栈的节点出栈，这些节点构成一个SCC Stack循环不变性 当节点被访问时入栈，当对后代节点递归访问完成后，stack的循环不变性为：当且仅当该节点能够到达stack中更早入栈的元素时，保留该节点在stack中，否则，将该节点以及更迟入栈的节点出栈，保持循环不变性 时间戳 DFN: 该节点是第几个被DFS访问的节点 LOW: 节点通过tree edge向下访问自己的后代，通过back edge向上访问自己的祖先，“Low” 记录了该节点通过子树最高可到达祖先（最小的DFN值） LOW总是小于等于DFN。当LOW &lt; DFN时，该元素被保留在栈中，当LOW = DFN时，认为该节点是root，出栈 LOW只有两种情况会更新 Tree edge: low[u] = min(low[u], low[v]); 子节点没有被访问过，递归访问v后更新low，子节点通过子树最高能够到达的祖先 Back edge: low[u] = min(low[u], dfn[v]); 子节点已经被访问过，注意更新对象为dfn[v], back edge直接访问祖先，祖先并不是自己的子树，所以不能通过祖先的low更新自身 注意节点颜色的更新和普通的DFS不同，普通DFS中如果节点递归完所有子节点就结束了，更新为黑色节点，因为普通DFS仅仅寻找一棵生成树。但Tarjan要寻找连通域，如果节点需要被保留在栈中则不认为其已经结束，否则连通域中后续节点如果访问该节点时会误判为cross edge，所以只有当节点出栈时才能更新其为黑色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Tarjan &#123; private List&lt;Integer&gt;[] adjList; private int nodeNum; private List&lt;List&lt;Integer&gt;&gt; sccList; private int time; Tarjan (int[][] list, int nodeNum) &#123; adjList = new LinkedList[nodeNum]; for (int i = 0; i &lt; nodeNum; i++) &#123; adjList[i] = new LinkedList&lt;&gt;(); &#125; for (int[] l : list) &#123; adjList[l[0]].add(l[1]); &#125; this.nodeNum = nodeNum; &#125; public void scc() &#123; int[] dfn = new int[nodeNum]; int[] low = new int[nodeNum]; int[] visited = new int[nodeNum]; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); time = 0; for (int i = 0; i &lt; nodeNum; i++) &#123; if (visited[i] == 0) sccUtil(i, visited, dfn, low, stack); &#125; &#125; private void sccUtil(int node, int[] visited, int[] dfn, int[] low, Deque&lt;Integer&gt; stack) &#123; visited[node] = 1; dfn[node] = low[node] = ++time; stack.push(node); for (int next : adjList[node]) &#123; if (visited[next] == 0) &#123; sccUtil(next, visited, dfn, low, stack); low[node] = Math.min(low[node], low[next]); &#125; // 对于有向图无向图都是一样的，不需要像判断是否存在环一样用father数组防止访问father节点 // 而且对于无向图，不需要tarjan算法，dfs bfs is ok else if (visited[next] == 1) &#123; low[node] = Math.min(low[node], dfn[next]); &#125; &#125; if (low[node] == dfn[node]) &#123; int top; List&lt;Integer&gt; scc = new LinkedList&lt;&gt;(); while (node != stack.peek()) &#123; top = stack.pop(); scc.add(top); visited[top] = 2; &#125; top = stack.pop(); scc.add(top); visited[top] = 2; sccList.add(scc); &#125; &#125;&#125; Kosaraju 该算法巧妙地利用了一个定理即一个图的反向图和原图具有一样的强连通分量。 如果连通域\(C_1\)单向连通\(C_2\)，即\(C_1-&gt;C_2\)，那么在图\(G\)的dfs中\(C_1\)可以到达\(C_2\)。然而，在逆向图中\(G&#39;\)中，两者的连通形式变为了\(C_1&lt;-C_2\)，此时如果再从\(C_1\)出发是无法到达\(C_2\)的。因此，在逆向图\(G&#39;\)中从finish时间最晚（为了保持与正向图一致的连通域访问顺序）的节点开始再次进行dfs，得到的每一棵生成树就是一个强连通域 步骤 对 \(G\) 进行DFS，并按照结束时间的顺序将顶点压入堆栈S，栈顶结束时间最晚 将 \(G=&lt;V, E&gt;\)中每一条边E逆向，得到逆向图 \(G^T=&lt;V,E^T&gt;\) 按序弹出堆栈S中的顶点v直到栈空，以v为顶点对逆向图 \(G^T\)进行DFS，每棵树即是一个联通分量 时间复杂度： \(O(V+E)\)，由于Kosaraju对Graph进行了两次完整的访问，运行速度比Tarjan慢 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;class Kosaraju &#123;public: Kosaraju(int n, vector&lt;pair&lt;int, int&gt;&gt; edge) &#123; node_num = n; adj.resize(node_num); for (auto it = edge.begin(); it != edge.end(); it++) adj[it-&gt;first].push_back(it-&gt;second); &#125; void excute_kosaraju() &#123; visited.resize(node_num); fill(visited.begin(), visited.end(), false); for (int i = 0; i &lt; node_num; i++) if (!visited[i]) dfs(i); transpose_graph(); fill(visited.begin(), visited.end(), false); while (!kosa_stack.empty()) &#123; int node = kosa_stack.top(); kosa_stack.pop(); if (!visited[node]) &#123; vector&lt;int&gt; conn; dfs_getscc(node, conn); scc.push_back(conn); &#125; &#125; &#125; void print_scc() &#123; for (auto conn = scc.begin(); conn != scc.end(); conn++) &#123; for (auto n = conn-&gt;begin(); n != conn-&gt;end(); n++) cout &lt;&lt; *n &lt;&lt; " "; cout &lt;&lt; endl; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; get_scc() &#123; return scc; &#125;private: int node_num; vector&lt;vector&lt;int&gt;&gt; adj; vector&lt;vector&lt;int&gt;&gt; transpose_adj; vector&lt;vector&lt;int&gt;&gt; scc; vector&lt;bool&gt; visited; stack&lt;int&gt; kosa_stack; void dfs(int node) &#123; visited[node] = true; for (auto it = adj[node].begin(); it != adj[node].end(); it++) if (!visited[*it]) dfs(*it); kosa_stack.push(node); &#125; void transpose_graph() &#123; transpose_adj.resize(node_num); for (int i = 0; i &lt; node_num; i++) for (auto it = adj[i].begin(); it != adj[i].end(); it++) transpose_adj[*it].push_back(i); &#125; void dfs_getscc(int node, vector&lt;int&gt; &amp;conn) &#123; visited[node] = true; for (auto it = transpose_adj[node].begin(); it != transpose_adj[node].end(); it++) if (!visited[*it]) dfs_getscc(*it, conn); conn.push_back(node); &#125;&#125;;int main() &#123; vector&lt;pair&lt;int, int&gt;&gt; edge&#123; &#123;0,1&#125;, &#123;2,0&#125;, &#123;1,2&#125;, &#123;2,1&#125;, &#123;1,5&#125;, &#123;5,4&#125;, &#123;4,5&#125;, &#123;3,4&#125; &#125;; int node = 6; Kosaraju kosa(node, edge); kosa.excute_kosaraju(); kosa.print_scc();&#125; 代码托管于github: scloudyy/CLRS [参考资料] https://www.geeksforgeeks.org/strongly-connected-components/ https://ide.geeksforgeeks.org/LCRcA2GT12 https://en.wikipedia.org/wiki/Strongly_connected_component https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm https://visualgo.net/en/dfsbfs https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>strongly connected component</tag>
        <tag>scc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础类型与位操作]]></title>
    <url>%2Fposts%2F7a01e2e7%2F</url>
    <content type="text"><![CDATA[基础类型 type space byte 1byte 8bit short 2byte 16bit int 4byte 32bit long 8byte 64bit float 4byte 32bit double 8byte 64bit 一个16进制数是4bit，1byte可以表示2个16进制数，一个int可以表示8个16进制数 有符号数最高位为符号位，0为正1为负，int范围是 \(-2^{31}\) ~ $ 2^{31}-1$ 位运算 与运算符 &amp; 两个bit都为1，结果才为1，否则结果为0 或运算符 | 两个bit只要有一个为1，那么结果就是1，否则就为0 非运算符 ~ 如果bit为0，结果是1，如果bit为1，结果是0 异或运算符 ^ 两个bit相同则结果为0，不同则结果为1 左移 &lt;&lt;，左移补零 右移 &gt;&gt;，右移补符号位 无符号右移，忽略符号位，空位都以0补齐 &gt;&gt;&gt; ，没有无符号左移，因为左移都是补零，不存在分歧 。最高位为符号位，0为正数，1为负数 1234567891011121314151617181920212223// 左移会影响符号位int a = 0x40000000; // a == 1073741824String str = Integer.toBinaryString(a); // "01000000000000000000000000000000"a &lt;&lt;= 1; // a == -2147483648str = Integer.toBinaryString(a); // "10000000000000000000000000000000"a &lt;&lt;= 1; // a == 0str = Integer.toBinaryString(a); // "00000000000000000000000000000000"// 有符号右移，符号位不变，右移补符号位a = 0xc0000000;str = Integer.toBinaryString(a); // "11000000000000000000000000000000"a &gt;&gt;= 1;str = Integer.toBinaryString(a); // "11100000000000000000000000000000"a = 0x40000000;str = Integer.toBinaryString(a); // "01000000000000000000000000000000"a &gt;&gt;= 1;str = Integer.toBinaryString(a); // "00100000000000000000000000000000"// 无符号左移a = 0xc0000000;str = Integer.toBinaryString(a); // "11000000000000000000000000000000"a &gt;&gt;&gt;= 1;str = Integer.toBinaryString(a); // "01100000000000000000000000000000" 二进制有符号数中，最高位为符号位，最高位为 1 代表负数，最高位为 0 代表正数。 负数在计算机中都是以补码的形式存在的（整数反正补码反码都一样） 原码：就是当前数字的二进制表现形式，如-1的原码是1000 0001 (Byte) 反码：正数的反码就是本身。负数的反码是二进制保留符号位，剩余位取反，比如-1的反码是1111 1110，也可以理解为-1的反码是其绝对值取反； 补码：正数的反码、补码、原码都是一样的，负数的补码是在其反码的基础上+1，比如-1的补码是1111 1111。 根据补码的转换形式，对一个数取反再加一可以得到该数的相反数 1234String s5 = Integer.toBinaryString(5); // 101String s_5 = Integer.toBinaryString(-5); // 11111111111111111111111111111011，可以看到-5的二进制是5的二进制取反后加一int n1 = ~5 + 1; // n1 = -5int n2 = ~-5 + 1; // n2 = 5 [参考资料] 位操作实现加减乘除四则运算]]></content>
      <categories>
        <category>technology</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>bit operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基本操作]]></title>
    <url>%2Fposts%2F45d3ebe2%2F</url>
    <content type="text"><![CDATA[创建ssh key与github通信 123ssh-keygen -t rsa -C &quot;your_email@example.com&quot;gedit ~/.ssh/id_rsa.pubssh -T git@github.com 基础操作 123456789101112131415git config --global core.editor vimgit config --global user.name "yourname"git config --global user.email "email@example.com"git log # 显示git的log，按q exitgit push -u origin master # 上面命令将本地的master分支推送到origin主机git branch # 查看所有分支git branch dev # 创建分支devgit checkout dev # 切换到分支devgit checkout -b dev # 新建并切换到分支devgit merge dev # 合并dev到当前分支git branch -d # 删除dev分支，只能删除已经merge的分支git push -u origin dev:dev_remote # 提交本地分支dev到origin，作为dev_remote分支。如果不写:dev_remote，则远程分支名默认与本地分支名相同git push -u origin :dev_remote # 删除origin的dev_remote分支，本地分支不会被删除 commit规范 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// blank line&lt;body&gt;// blank line&lt;footer&gt; 7种type： feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动]]></content>
      <categories>
        <category>technology</category>
        <category>tools</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典树 Trie]]></title>
    <url>%2Fposts%2F3c29c9d3%2F</url>
    <content type="text"><![CDATA[Trie树 字典树，检索树。retrieve -&gt; trie 与hash的比较 比较 trie树 hash 时间 O(1) O(1) 空间 对于有前缀重复的key，空间更优 操作 查询key，查询前缀 查询key 实现 每个节点（出root）代表一个实际字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;class TrieNode &#123;public: // 一个TrieNode本身代表了一个存在的字符，如果单给一个节点要获取该节点代表什么字符，可以在TrieNode里再加一个char cur_char成员，但是一般没有这种需求，因为Trie树一般用于查询某字符串时候存在，并不需要获取单个节点的信息 TrieNode() &#123; isString = false; &#125; unordered_map&lt;char, TrieNode*&gt; chars; // chars表示当前节点之后该存在哪些字符 bool isString; // 标记该字符代表了一个string的结束&#125;;class Trie &#123;public: Trie() &#123; root = new TrieNode(); // root中最开始的hashmap为空，代表该深度下不存在字符 &#125; void insert(const string &amp;word) &#123; TrieNode *p = root; for (auto c : word) &#123; if (p-&gt;chars.find(c) == p-&gt;chars.end()) p-&gt;chars[c] = new TrieNode(); p = p-&gt;chars[c]; &#125; p-&gt;isString = true; &#125; bool searchWord(const string &amp;word) &#123; TrieNode *p = searchNodePos(word); if (p == nullptr) return false; else if (p-&gt;isString) return true; else return false; &#125; bool searchPrefix(const string &amp;prefix) &#123; TrieNode *p = searchNodePos(prefix); if (p == nullptr) return false; else return true; &#125; vector&lt;string&gt; getPrefixWord(const string prefix) &#123; vector&lt;string&gt; ans; TrieNode *cur = searchNodePos(prefix); if (cur) &#123; prefixWordBacktracking(prefix, cur, ans); // 使用回溯获取所有具有前缀的string &#125; return ans; &#125;private: TrieNode * root; //或者字符串word最后一个字符的TrieNode节点，如果前缀不符合返回nullptr TrieNode *searchNodePos(const string &amp;word) &#123; TrieNode *p = root; for (auto c : word) &#123; if (p-&gt;chars.find(c) == p-&gt;chars.end()) return nullptr; p = p-&gt;chars[c]; &#125; return p; &#125; void prefixWordBacktracking(string cur_str, TrieNode *root, vector&lt;string&gt; &amp;ans) &#123; if (root-&gt;isString) ans.push_back(cur_str); // root指向cur_str最后一个字符的TrieNode节点，将cur_str作为前缀，将包含前缀的所有字符串放入ans中 for (auto it = root-&gt;chars.begin(); it != root-&gt;chars.end(); it++) &#123; cur_str.push_back(it-&gt;first); prefixWordBacktracking(cur_str, it-&gt;second, ans); cur_str.pop_back(); &#125; &#125;&#125;;int main() &#123; Trie trie; trie.insert("abc"); trie.insert("acc"); trie.insert("abcd"); trie.searchWord("abc"); trie.searchPrefix("ab"); vector&lt;string&gt; prefix_word = trie.getPrefixWord("ab");&#125; 使用场景 一个一个字母遍历 需要节省有大量重复前缀的字符串的存储空间 查找字符串前缀]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++综合基础知识]]></title>
    <url>%2Fposts%2Fc591d755%2F</url>
    <content type="text"><![CDATA[基本类型的表示范围 1234567891011121314151617181920#include&lt;iostream&gt;#include &lt;limits&gt; using namespace std;int main() &#123; cout &lt;&lt; "bool:\t\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(bool) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;bool&gt;::max() &lt;&lt; "\t\t\t\tMin: " &lt;&lt; numeric_limits&lt;bool&gt;::min() &lt;&lt; endl; cout &lt;&lt; "char:\t\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(char) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;char&gt;::max() &lt;&lt; "\t\t\t\tMin: " &lt;&lt; numeric_limits&lt;char&gt;::min() &lt;&lt; endl; cout &lt;&lt; "signed char:\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(signed char) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;signed char&gt;::max() &lt;&lt; "\t\t\t\tMin: " &lt;&lt; numeric_limits&lt;signed char&gt;::min() &lt;&lt; endl; cout &lt;&lt; "unsigned char:\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(unsigned char) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;unsigned char&gt;::max() &lt;&lt; "\t\t\t\tMin: " &lt;&lt; numeric_limits&lt;unsigned char&gt;::min() &lt;&lt; endl; cout &lt;&lt; "short:\t\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(short) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;short&gt;::max() &lt;&lt; "\t\t\tMin: " &lt;&lt; numeric_limits&lt;short&gt;::min() &lt;&lt; endl; cout &lt;&lt; "int:\t\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(int) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;int&gt;::max() &lt;&lt; "\t\t\tMin: " &lt;&lt; numeric_limits&lt;int&gt;::min() &lt;&lt; endl; cout &lt;&lt; "unsigned int:\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(unsigned int) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;unsigned int&gt;::max() &lt;&lt; "\t\t\tMin: " &lt;&lt; numeric_limits&lt;unsigned int&gt;::min() &lt;&lt; endl; cout &lt;&lt; "long:\t\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(long) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;long&gt;::max() &lt;&lt; "\t\t\tMin: " &lt;&lt; numeric_limits&lt;long&gt;::min() &lt;&lt; endl; cout &lt;&lt; "unsigned long:\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(unsigned long) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;unsigned long&gt;::max() &lt;&lt; "\t\t\tMin: " &lt;&lt; numeric_limits&lt;unsigned long&gt;::min() &lt;&lt; endl; cout &lt;&lt; "long long:\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(long long) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;long long&gt;::max() &lt;&lt; "\tMin: " &lt;&lt; numeric_limits&lt;long long&gt;::min() &lt;&lt; endl; cout &lt;&lt; "double:\t\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(double) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;double&gt;::max() &lt;&lt; "\t\tMin: " &lt;&lt; numeric_limits&lt;double&gt;::min() &lt;&lt; endl; cout &lt;&lt; "float:\t\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(float) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;float&gt;::max() &lt;&lt; "\t\tMin: " &lt;&lt; numeric_limits&lt;float&gt;::min() &lt;&lt; endl; cout &lt;&lt; "size_t:\t\t" &lt;&lt; "Bytes: " &lt;&lt; sizeof(size_t) &lt;&lt; "\tMax: " &lt;&lt; numeric_limits&lt;size_t&gt;::max() &lt;&lt; "\tMin: " &lt;&lt; numeric_limits&lt;size_t&gt;::min() &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; "Platform: Win10 &amp;&amp; VS2017" &lt;&lt; endl;&#125; 1byte = 8 bit，int, stort, long, long long默认都是有符号即有正负范围，无符号即范围始终为正数需要加上unsigned前缀。由于零也算正数，占用一个正数空间，所以正数绝对值比负数绝对值小一，例如int所占位数为4byte = 32 bit，有符号signed范围：2^31-1 ~ -2^31即：2147483647 ~ -2147483648，无符号unsigned范围：2^32-1 ~ 0即：4294967295 ~ 0 另外对于浮点数推荐使用double类型基本上不会有错。其精度比float高，且在某些机器上计算速度更快。 判断两浮点数是否相等需要设置精度 123double eps = 10e-8;double a1 = 1.55555553453, a2 = 1.5555556456;if (a1 - a2 &gt; -eps &amp;&amp; a1 - a2 &lt; eps) &#123;&#125; 操作符优先级 符号 操作类型 执行顺序 [ ] ( ) . –&gt; 前缀++ 前缀–– 表达式 从左到右 后缀++ 后缀–– sizeof &amp; * + – ~ ! 一元操作符 从右到左 type(类型说明) 一元操作符 从右到左 * / % 乘除法 从左到右 + – 加减法 从左到右 &lt;&lt; &gt;&gt; 位移操作 从左到右 &lt;&gt; &lt;= &gt;= 大小关系 从左到右 == != 相等关系 从左到右 &amp; 位与运算符 从左到右 ^ 位异或运算符 从左到右 位或运算符 从左到右 &amp;&amp; 逻辑与 从左到右 逻辑或 ? : 条件判断表达式 从右到左 = *= /= %= += –= &lt;&lt;= &gt;&gt;= &amp;= ^= = 简单混合操作 , 顺序赋值 从左到右]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的tuple]]></title>
    <url>%2Fposts%2F790fc257%2F</url>
    <content type="text"><![CDATA[pair将一对值组合成一个值，这一对值可以具有不同的数据类型（T1和T2），两个值可以分别用pair的两个公有函数first和second访问。包含在头文件中 基本操作 pair&lt;v1, v2&gt; p(v1, v2) ： 使用构造函数初始化 pair&lt;v1, v2&gt; p(p2) ： 拷贝构造函数 123pair&lt;int, int&gt; p1; //默认构造函数pair&lt;int, int&gt; p2(1, 3); // 使用构造函数初始化pair&lt;int, int&gt; p3(p2); // 拷贝构造函数 通过first和second访问两个元素 1234pair&lt;int, int&gt; p;p1.first = 1;p1.second = 3;cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; endl; make_pair(v1, v2) ： 返回一个通过指定元素类型初始化后的pair 12tuple&lt;int, int&gt; t;t = make_tuple(1, 3);]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>pair</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索 Binary Search]]></title>
    <url>%2Fposts%2Fdf92661%2F</url>
    <content type="text"><![CDATA[二叉搜索 输入： L: “有序”数组 key: 能够对数组中每个元素进行逻辑判断的函数，如arr[k] &gt;= target “有序”指将key函数应用到数组中每个元素后，数组将被分为两部分，左半部分所有元素逻辑值为false，右半部分所有元素逻辑值为true。左右都可以为空 输出：逻辑数组中右半部分第一个元素的坐标 123456789101112131415161718192021222324// high指向的元素坐标永远为true，从而保持循环不变性int binary_search(vector&lt;int&gt; vec, int target) &#123; int low = 0; int high = vec.size(); // high最初指向的是数组最后一个元素的后一个位置，如果二叉搜索结束后high仍然指向该位置，则说明数组中没有满足逻辑判断的元素 int mid; while (low &lt; high) &#123; mid = low + (high-low) / 2; // 使用 (high-low) 避免溢出 // 由于 high 用于指向正确的，可能一直等于 mid，如果使用 mid=high-(high-low)/2，可能引发死循环 if (vec[mid] &gt;= target) &#123; high = mid; // high指向的坐标永远满足vec[mid] &gt;= target， // high最终的坐标是vec中第一个满足该条件的元素坐标 &#125; else &#123; low = mid + 1; // 当前mid为flase，则除了左半边，当前mid也可以被排除，所以low比mid再右移一位 // 其实low和high每次都指向的是潜在的validate目标，最后结束时两者也会相等。 &#125; &#125; return (high &lt; N) &amp;&amp; (arr[high] == x); // 如果 high==N，则 vec 不存在该元素&#125; 二叉搜索找的是有序数组中target的分界线，满足arr[k] &gt;= target的第一个/最小元素，或者满足arr[k] &lt; target的最后一个/最大元素。对于最大最小元素的不同搜索要求，使用key函数的变换将其转换为满足前false后true的逻辑函数，例如搜寻满足arr[k] &lt; target的最后一个元素，key可以设置为arr[mid+1]&gt;=target 二叉搜索可以拓展应用到“寻找某范围内满足条件A的最大值/最小值”这类问题上，其搜索空间并不是特定的数组，而只是一个值域，例如LC69. Sqrt(x), LC437. Copy Books 二叉搜索找出的是满足逻辑判断的第一个元素的坐标，至于该坐标是不是返回值，可以放到外面来判断。如果直接在while循环里遇到 == target 就返回，对于长度为1的输入来说就需要单独判断。 如果对target判断过多，以至于需要独立判断== target，如LC33. Search in Rotated Sorted Array，可以使用以下模板 12345678910111213141516int search(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size(), mid; while (low &lt; high) &#123; mid = low + (high - low) / 2; if (nums[mid] == target) &#123; high = mid; &#125; else if (nums[mid] &gt; target) &#123; // 每次都指向潜在的validate目标 high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return (high &lt; nums.size() &amp;&amp; nums[high] == target) ? high : -1;&#125; [参考资料] https://stackoverflow.com/questions/504335/what-are-the-pitfalls-in-implementing-binary-search/36807368#36807368 https://coldattic.info/post/95/]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++容器适配器]]></title>
    <url>%2Fposts%2Fe9f4b4e7%2F</url>
    <content type="text"><![CDATA[适配器 C++提供了三种容器适配器： stack：默认基于deque queue：默认基于deque priority_queue：默认基于vector 虽然我们完全可以使用deque模拟stack，但是deque提供的操作接口远多于stack需要的。因此C++设计了适配器来封装原本的顺序容器，仅保留基础类型的部分功能 初始化 适配器只有两种构造器：默认构造器，接受基础容器的构造器，其中priority_queue只有默认构造器 123456deque&lt;int&gt; deq&#123;1, 2, 3&#125;;stack&lt;int&gt; stack1; // 默认构造器，初始化一个空的stackstack&lt;int&gt; stack2(deque&lt;int&gt;&#123;1, 2, 3&#125;); // 接受基础容器的构造器，由于基础类型默认为deque，参数必须是deque类型的// stack&lt;int&gt; stack2&#123;1, 2, 3&#125;; 错误// stack&lt;int&gt; stack2(vector&lt;int&gt;&#123;1, 2, 3&#125;); 错误stack&lt;int, vector&lt;int&gt;&gt; stack3(vector&lt;int&gt;&#123;1, 2, 3&#125;); 可以指定基础容器以替换默认的基础容器 1stack&lt;int, vector&lt;int&gt;&gt; stack3(vector&lt;int&gt;&#123;1, 2, 3&#125;); // 将stack的基础容器替换为vector 6中顺序容器中，array 和 forward_list 不能作为基础容器，因为三种适配器都需要对最后一个元素进行增删 stack只需要用到push_back, pop_back, back 操作，所以剩余的4中容器都可以作为其基础容器，甚至包括string queue需要back, push_back, front, push_front 操作，其基础容器除去vector与string，只能是deque与list priority_queue需要front, push_back, pop_back同时其需要 随机存取，其基础容器除去list，只能是vector, deque, string stack 定义在头文件中 123s.pop(); 删除栈顶元素，但不返回其值s.top(); 返回栈顶元素的值，但不删除此元素s.push(item); 在栈顶压入新元素item queue &amp; priority_queue 两者都定义在头文件中 1234567891011q.push(item); //对于queue，在队尾压入一个新元素 //对于priority_queue，在基于优先级的适当位置插入新元素q.pop(); //删除queue中队首或priority_queue中优先级最高的元素，但不返回//queue only:q.front(); //返回队首元素的值，但不删除该元素q.back(); //返回队尾元素的值，但不删除该元素//priority_queue only:q.top(); //返回具有最高优先级的元素值，但不删除该元素 queue遵循先进先出(FIFO)的原则存储元素，priority_queue类似堆 12priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap; // 值越大，优先级越高priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap; // 值越小，优先级越高 priority_queue自定义比较 1234567891011121314151617181920212223242526struct Point &#123; int y; int x; int height; Point(int y, int x, int h) : y(y), x(x), height(h) &#123;&#125;&#125;;// 后面的元素处于top// 自定义比较函数，要放在一个结构体里面。// priority_queue默认是最大堆，即p1, p2相比，如果为true则将p2插在后面，return p1 &lt; p2，即p2较大则将p2放在后面// 自定义的比较中，return p1 &gt; p2，即p2较小则将其放在后面struct cmp &#123; bool operator() (const Point &amp;p1, const Point &amp;p2) &#123; return p1.height &gt; p2.height; &#125;&#125;;int main() &#123; // 第一个参数指定元素类型，第二个参数指定基础容器类型，这里将基础容器类型更改为vector，第三个参数为自定义比较操作 priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; que; Point p1(1, 2, 3); Point p2(2, 2, 4); Point p3(1, 1, 5); que.push(p1); que.push(p2); que.push(p3); // top -&gt; (y=1 x=2 height=3) (y=2 x=2 height=4) (y=1 x=1 height=5)&#125; 基于lambda的比较函数写法：priority_queue接收函数类型作为模板参数(decltype(cmp2))，同时构造器需要输入执行比较函数本身的指针 1234auto cmp2 = [](const Point &amp;p1, const Point &amp;p2) &#123; return p1.height &gt; p2.height; &#125;;priority_queue&lt;Point, vector&lt;Point&gt;, decltype(cmp2)&gt; que2(cmp2);]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>container adaptor</tag>
        <tag>stack</tag>
        <tag>queue</tag>
        <tag>prioprity_queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ string小结]]></title>
    <url>%2Fposts%2F39d31ed0%2F</url>
    <content type="text"><![CDATA[程序中经常遇到string的操作，除了C++顺序容器的通用操作外，string还单独定义很多简便的函数，总结一下很有必要 初始化 string s1; string s2(s1); string s3 = s1; string s4("value"); string s5 = "value"; string s6(n, 'c'); 以上是顺序容器通用操作 string s7(char pointer, num); 使用字符串数组指针初始化string，从char pointer开始共num个字符，如果num没有指定则到停止符为止 string s8(s1, pos); 从s1的pos开始，pos照例从0开始计数 string s9(s1, pos1, pos2); 从s1的pos1开始到pos2为止 123456const char *charp = "hello world";char chararr[] = &#123; 'h', 'e', 'l' &#125;;string s71(charp); // s71: "hello world"string s72(chararr); // s72: 字符串无效，因为chararr没有终止符string s73(chararr + 1, 2); // s73: "el"string s8(s71, 1, 4); // s8: "ello" 取子串 substr s.substr(pos) 截取s中从pos开始（包括0）到末尾的所有字符的子串，并返回 s.substr(pos, n) 截取s中从pos开始（包括0）的n个字符的子串，并返回 更多更改字符串的方式 来自"C++ Primer" 123456// 删除首部的0string s("001");int i = 0;while (s[i] == '0') i++; // 统计0的长度s.erase(0, i); // 从index 0开始，删除i个字符 查找 来自"C++ Primer" 与数值的转换 来自"C++ Primer" 1string s = to_string(42); 字符操作 来自"C++ Primer" [参考资料] C++ Primer]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++关联容器小结]]></title>
    <url>%2Fposts%2F4c435fff%2F</url>
    <content type="text"><![CDATA[关联容器与顺序容器的区别在于，顺序容器线性存储并通过位置索引存取，关联容器则通过关键字存取 关联容器 有序关联容器(按key值排序) map: key-value pairs set: 只有key值 multimap: 允许key重复的map，定义在中 multiset: 允许key重复的set，定义在中 无序关联容器 unordered_map: 通过hash组织的map unordered_set: 通过hash组织的set unordered_multimap: 通过hash组织的multimap，定义在中 unordered_multiset: 通过hash组织的multiset，定义在中 map中的元素都是pair对象，pair中first是const成员，对应key值，second对应value range-based for 与 解引用迭代器 获得的都是value_type，对于set，value_type=key_type；对于map，value_type=pair&lt;const key_type, mapped_type&gt; 123456789101112131415map&lt;string, int&gt; m = &#123; &#123;"a", 1&#125;, &#123;"b", 2&#125; &#125;;for (const auto &amp;e : m) &#123; cout &lt;&lt; "key:" &lt;&lt; e.first &lt;&lt; " value:" &lt;&lt; e.second &lt;&lt; endl;&#125;for (auto map_it = m.cbegin(); map_it != m.cend(); map_it++) &#123; cout &lt;&lt; "key:" &lt;&lt; map_it-&gt;first &lt;&lt; " value:" &lt;&lt; map_it-&gt;second &lt;&lt; endl;&#125;unordered_set&lt;int&gt; s;for (int i = 5; i &gt;= 0; i--) s.emplace(i);for (const auto &amp;v : s) cout &lt;&lt; v &lt;&lt; endl;for (auto it = s.cbegin(); it != s.cend(); it++) cout &lt;&lt; *it &lt;&lt; endl; 在有序关联容器中，key的类型需要支持 &lt; 操作，否则需要自定义比较操作 在无序关联容器并不对key值进行排序，而使用hash函数构建容器，key的类型需要支持hash 以及 == 操作，否则需要自定义hash以及== 有序关联容器如set可以用于代替HashHeap，实现带remove操作的Heap 123*set.begin(); // 最小值，注意set, map没有back()或front()*set.rbegin(); // 最大值set.erase(prev(set.rbegin().base())); // 删除最大值，注意erase只接受正向迭代器，需要将rbegin转换为指向同一位置的正向迭代器 Type key_type key值的类型 value_type 对于set，value_type就是key_type；对于map，value_type是pair的类型&lt;const key_type, mapped_type&gt; mapped_type 专属于map，指与key关联的value的类型 添加元素 c.insert(value); 插入的value类型为value_type c.insert(iterator1, iterator2); c.insert({a1, a2, ...}); c.emplace(args); c.insert(iterator, value); 从iterator开始查找应该在哪里插入value并进行insert操作 c.emplace(iterator, args); 对于map和set，如果key值已经存在与容器中，则插入不会执行，insert的返回值是一个pair，first是指向key值元素的迭代器，second是一个bool值，指示插入是否被执行；对于multimap和multiset，key值可以重复，插入总会执行，insert的返回值是指向新元素的迭代器 1234map&lt;string, int&gt; m&#123; &#123;"b", 3&#125; &#125;;auto ret1 = m.insert(&#123; "a", 1 &#125;); // ret1 = &#123;&#123;"a",1&#125;, true&#125;auto ret2 = m.insert(&#123; "a", 2 &#125;); // ret2 = &#123;&#123;"a",1&#125;, false&#125;cout &lt;&lt; (++ret1.first)-&gt;second; // 输出 3 emplace的用法和返回值都与insert相同，但是不同于insert拷贝一个已有或临时对象，empalce直接传入构造参数，在map内部构造对象，效率比insert更高 12auto ret3 = m.emplace("c", 1); // ret3 = &#123;&#123;"c",1&#125;, true&#125;auto ret4 = m.emplace("c", 2); // ret4 = &#123;&#123;"c",1&#125;, false&#125; 删除元素 c.erase(key); key类型为key_type，返回被删除的元素个数 c.erase(iterator); 返回iterator后一个元素的迭代器 c.erase(iterator1, iterator2); 返回iterator2 获取元素 下标的方式 c[key] key类型为key_type，返回值类型为mapped_type，如果key不存在则自动添加key值新元素并默认初始化 c.at(key) 如果key不存在则抛出out_of_range 12345678map&lt;string, int&gt; m&#123; &#123;"b", 3&#125; &#125;;auto ret1 = m["a"]; // "a"不存在则自动创建，ret1值为0try &#123; auto ret2 = m.at("c"); // "c"不存在，抛出out_of_range异常&#125;catch (out_of_range)&#123; cout &lt;&lt; "out of range";&#125; 下标索引只对map和unordered_map有效。对于set，key没有对应的值；对于multimap或unordered_map，key可能对应多个值 下标索引获取的是mapped_type，解引用迭代器获取的是value_type。由于set中value_type就是key_type，所以想要获得set中的key值，可以解引用迭代器 由于对于map下标索引会自动创建元素，所以如果只想知道容器中是否存在该元素，不能使用下标索引 迭代器 c.find(key); 返回指向key值元素的第一个迭代器，如果不存在key则返回end() c.count(key); 返回key值元素的个数 c.lower_bound(key); 返回拥有key值的第一个元素的迭代器，如果key不存在则返回可以插入的位置 c.upper_bound(key); 返回拥有key值的最后一个元素后一个位置的迭代器，如果key不存在则返回可以插入的位置 c.equal_range(key); 返回pair{lower_bound, upper_bound} 123456789map&lt;string, int&gt; m&#123; &#123;"a", 1&#125;, &#123;"c", 3&#125; &#125;;auto p1 = m.lower_bound("b"); // p1 = &#123;"c", 3&#125;auto p2 = m.upper_bound("b"); // p2 = &#123;"c", 3&#125;m.insert(p1, &#123; "b", 2 &#125;); // 从p1开始查找哪里应该插入&#123; "b", 2 &#125;multimap&lt;string, int&gt; multi_m&#123; &#123;"a", 1&#125;, &#123; "a", 2 &#125; &#125;;for (auto pos = multi_m.equal_range("a"); pos.first != pos.second; pos.first++) &#123; // 打印所有以"a"为key的元素 cout &lt;&lt; "key:" &lt;&lt; pos.first-&gt;first &lt;&lt; " value:" &lt;&lt; pos.first-&gt;second &lt;&lt; endl;&#125; [参考资料] C++ Primer]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>associate container</tag>
        <tag>map</tag>
        <tag>set</tag>
        <tag>multimap</tag>
        <tag>multiset</tag>
        <tag>unordered_map</tag>
        <tag>unordered_set</tag>
        <tag>unordered_multimap</tag>
        <tag>unordered_multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序 Topological Sort]]></title>
    <url>%2Fposts%2Fa1ccdb7%2F</url>
    <content type="text"><![CDATA[算法描述 输入：有向无环图(Directed Acyclic Graph, DAG) G 拓扑排序：将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若存在边 (u,v)，则u作为前驱节点， 在线性序列中排在在 v 之前。拓扑排序的序列不是唯一的，满足上述定义的任一线性序列均称作它的拓扑序列 拓扑排序的意义：通常用于工程流程图排序，拓扑序列中的顶点的次序指明了在开始某一项活动时，哪些前驱活动必须被完成，从而使整个工程顺序进行。将这些顶点表示活动，边表示活动先后次序的有向图称做顶点活动网(Activity On Vertex network, AOV)。 实现 对有向无环图进行DFS，依照DFS过程中每个节点的finish属性对节点进行排序。每当一个节点结束搜索就将其放入队列，等DFS结束后整个队列就是拓扑序列 1234TOPOLOGICAL-SORT(G) call DFS(G) to compute finishing times v.f for each vertex v as each vertex is finished, insert it onto the front of a linked list return the linked likst of vertices C++ 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;vector&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;unordered_set&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;using namespace std;class TopologicalSort &#123;public: TopologicalSort(vector&lt;pair&lt;string, string&gt;&gt; edge) &#123; for (auto it = edge.begin(); it != edge.end(); it++) &#123; node.insert(it-&gt;first); node.insert(it-&gt;second); adj.insert(&#123; it-&gt;first, it-&gt;second &#125;); &#125; node_num = node.size(); &#125; void execute() &#123; for_each(node.begin(), node.end(), [this](string n) &#123;visited[n] = false; &#125;); for_each(node.begin(), node.end(), [this](string n) &#123;if (!visited[n]) dfs(n); &#125;); &#125; void print_topological_list() &#123; for_each(topological_list.begin(), topological_list.end(), [](string n) &#123;cout &lt;&lt; n &lt;&lt; endl; &#125;); &#125;private: int node_num; unordered_multimap&lt;string, string&gt; adj; unordered_set&lt;string&gt; node; unordered_map&lt;string, bool&gt; visited; list&lt;string&gt; topological_list; void dfs(string n) &#123; visited[n] = true; for (auto pos = adj.equal_range(n); pos.first != pos.second; pos.first++) if (!visited[pos.first-&gt;second]) dfs(pos.first-&gt;second); topological_list.push_front(n); &#125;&#125;;int main() &#123; vector&lt;pair&lt;string, string&gt;&gt; edge&#123; &#123;"shirt", "tie"&#125;, &#123;"shirt", "belt"&#125;, &#123;"tie", "jacket"&#125;, &#123;"belt", "jacket"&#125;, &#123;"pants", "belt"&#125;, &#123;"pants", "shoes"&#125;, &#123;"undershorts", "pants"&#125;, &#123;"undershorts", "shoes"&#125;, &#123;"socks", "shoes"&#125;, &#123;"watch", "watch"&#125; &#125;; TopologicalSort topological(edge); topological.execute(); topological.print_topological_list();&#125; 代码托管于github: scloudyy/CLRS indegree实现topological sort Alien Dictionary There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language. You may assume all letters are in lowercase.You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.If the order is invalid, return an empty string.There may be multiple valid order of letters, return the smallest in lexicographical order Example Given the following words in dictionary, 12&gt; [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]&gt; The correct order is: "wertf" 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Solution &#123; public String alienOrder(String[] words) &#123; Map&lt;Character, Set&lt;Character&gt;&gt; graph = constructGraph(words); return topologicalSorting(graph); &#125; private Map&lt;Character, Set&lt;Character&gt;&gt; constructGraph(String[] words) &#123; Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); // create nodes for (int i = 0; i &lt; words.length; i++) &#123; for (int j = 0; j &lt; words[i].length(); j++) &#123; char c = words[i].charAt(j); if (!graph.containsKey(c)) &#123; graph.put(c, new HashSet&lt;Character&gt;()); &#125; &#125; &#125; // create edges for (int i = 0; i &lt; words.length - 1; i++) &#123; int index = 0; while (index &lt; words[i].length() &amp;&amp; index &lt; words[i + 1].length()) &#123; if (words[i].charAt(index) != words[i + 1].charAt(index)) &#123; graph.get(words[i].charAt(index)).add(words[i + 1].charAt(index)); break; &#125; index++; &#125; &#125; return graph; &#125; private Map&lt;Character, Integer&gt; getIndegree(Map&lt;Character, Set&lt;Character&gt;&gt; graph) &#123; Map&lt;Character, Integer&gt; indegree = new HashMap&lt;&gt;(); for (Character u : graph.keySet()) &#123; indegree.put(u, 0); &#125; for (Character u : graph.keySet()) &#123; for (Character v : graph.get(u)) &#123; indegree.put(v, indegree.get(v) + 1); &#125; &#125; return indegree; &#125; private String topologicalSorting(Map&lt;Character, Set&lt;Character&gt;&gt; graph) &#123; Map&lt;Character, Integer&gt; indegree = getIndegree(graph); // as we should return the topo order with lexicographical order // we should use PriorityQueue instead of a FIFO Queue Queue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;(); // put nodes with 0 indegree into queue for (Character u : indegree.keySet()) &#123; if (indegree.get(u) == 0) &#123; queue.offer(u); &#125; &#125; StringBuilder sb = new StringBuilder(); while (!queue.isEmpty()) &#123; Character head = queue.poll(); sb.append(head); for (Character neighbor : graph.get(head)) &#123; indegree.put(neighbor, indegree.get(neighbor) - 1); if (indegree.get(neighbor) == 0) &#123; queue.offer(neighbor); &#125; &#125; &#125; // if there is cycle in graph, return "" if (sb.length() != indegree.size()) &#123; return ""; &#125; return sb.toString(); &#125;&#125; 参考 Introduction to Algorithms]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>CLRS</tag>
        <tag>sort</tag>
        <tag>topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广度优先搜索与深度优先搜索 BFS && DFS]]></title>
    <url>%2Fposts%2Ff9b74bc%2F</url>
    <content type="text"><![CDATA[广度优先搜索 搜索策略：从顶点s出发，搜索s所有子节点，等找到s所有子节点之后，再进入子节点搜索。BFS对有向与无向图都适用 为每个顶点着色以保持搜索轨迹： 白色：未被发现的顶点 黑色：所有子节点已经搜索完毕，与黑色节点相连的都是非白色（灰色或黑色）节点 灰色：已被发现，但是子节点并未被搜索完毕，灰色节点可能与白色节点相连 广度优先树：BFS会建立一棵root为源点s的广度优先树，其包含了图中s可以到达的所有节点v。广度优先树中节点v到root s的路径对应了图中v到s的最短路径。在Prime最小生成树算法，和Dijkstra单源最短路径算法中，都采用了与BFS 算法类似的思想 BFS 与 Dijkstra 在无权图或所有边权重相等的图中表现是一致的。 Dijkstra relaxes every edges of the current vertex, and then visit next unvisted vertex which possess the minimal distance to the source vertex. When the edges' weight all equal to 1, the distance of unvisited vertices to the source only relate to the depth of the tree rooted at source, so Dijkstra degenerate to BFS at this time. 伪代码 假设输入的图 \(G=&lt;V,E&gt;\) 使用邻接链表表示 123456789101112131415161718BFS(G, s) for each vertex u in G.V - &#123;s&#125; u.color = white u.d = MAX // u.d表示节点u到源点s的距离 u.father = NIL // u.father表示节点u的父节点 s.color = black s.d = 0 s.father = NIL Q = NIL ENQUEUE(Q, s) while Q != NIL u = DEQUEUE(Q) for each v in G.Adj[u] v.color = gray v.d = u.d + 1 v.father = u ENQUEUE(Q, v) u.color = balck 复杂度： 邻接链表： \(\Theta(V + E)\) 邻接矩阵： \(\Theta(V^2)\) 深度优先搜索 搜索策略：尽可能深地探索图的节点，如果节点所有的边已经被探索，则回溯到上一节点探索其剩余的未被探索的边 深度优先森林由于深度优先搜索会从不同节点出发，所以会生成深度优先森林，有深度优先树构成 每个节点有u.d属性，代表被发现的时间，u.f属性，代表结束的时间，即其子节点全部被探索完毕。在深度优先搜索中，这两个时间具有层级关系。如果节点v的开始结束时间[v.d, v.f]包含于u的开始结束时间，则v是u的子节点，如果两者不相交，则两节点没有层级关系 顶点着色与BFS一致： 白色：未被发现的顶点 灰色：已被发现，但是子节点并未被搜索完毕 黑色：所有子节点已经搜索完毕 边的分类： 深度优先搜索的同时能够得到生成树( spanning tree )，并能够对边进行分类 对于有向图中的每条边(u,v)： 树边 tree edges：代表(u,v)是生成树树中的边，从树中的节点u指向后代v。第一次探索时v是白色 正向边 froward edges：与树边一样，同样是生成树中节点u指向后代节点v的边，只是在之前的搜索中，uv已经在生成树中，所以(u,v)已经不能算是树边了。第一次探索时v是黑色，且u discover的时间早，其是v的祖先，u.d &lt; v.d 反向边 back edges：存在自环。第一次探索时v是灰色 交叉边 cross edges：代表u,v没有血缘关系。第一次探索时v是黑色，u discover的时间比v晚，u.d &gt; v.d 对于无向图中的每条边(u,v)：只存在树边与反向边 复杂度： 邻接链表： \(\Theta(V + E)\) 邻接矩阵： \(\Theta(V^2)\) DFS探索有向/无向图并对边进行分类 大多数时候我们只需要避免在dfs时形成环，那么只需要记录node是否被visited，不访问已经被visited的node就能顺利进行dfs；如果我们要判断是否存在环，就需要记录node是unvisited, visited, or finished，只有访问visited的node就是环的特征；如果需要识别四种边，则需要以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class Learn &#123; public static void main(String[] args) &#123; int[][] list = new int[][]&#123;&#123;1,2&#125;, &#123;2,3&#125;, &#123;3,1&#125;&#125;; DirectedGraph dg = new DirectedGraph(list); dg.dfs(); UndirectedGraph udg = new UndirectedGraph(list); udg.dfs(); &#125;&#125;class DirectedGraph&#123; private Map&lt;Integer, List&lt;Integer&gt;&gt; adjList; private int maxNodeLabel; private int[] visited; // record the first visit time private int[] finished; // record the finish time private int time; DirectedGraph(int[][] list) &#123; adjList = new HashMap&lt;&gt;(); // if input parameter has indicate the number of node, then don't need to use Map to represent adjList, just use List maxNodeLabel = 0; for (int[] li : list) &#123; adjList.computeIfAbsent(li[0], key -&gt; new LinkedList&lt;&gt;()).add(li[1]); adjList.computeIfAbsent(li[1], key -&gt; new LinkedList&lt;&gt;()); maxNodeLabel = Math.max(maxNodeLabel, Math.max(li[0], li[1])); &#125; visited = new int[maxNodeLabel + 1]; finished = new int[maxNodeLabel + 1]; time = 0; &#125; public void dfs() &#123; for (Integer node : adjList.keySet()) if (visited[node] == 0) // traverse over the key of adjList, if node has not been discovered, the dfs it exeDfs(node); &#125; private void exeDfs(Integer cur) &#123; visited[cur] = ++time; // record visit time for (Integer next : adjList.get(cur)) &#123; if (finished[next] != 0) &#123; // if next has finished discovery, next is a black cur if (visited[cur] &lt; visited[next]) &#123; // if cur's visit time less than next's visit time, then cur is the ancestor of next System.out.println("(" + cur + ", " + next + ") : forward edge"); &#125; else &#123; // else cur and next are not relatives System.out.println("(" + cur + ", " + next + ") : cross edge"); &#125; &#125; else &#123; // if next has not finished discovery // if you don't need to distinct forward and cross edge, then maybe you don't need to record finish time // and just use the code below to perform right dfs if (visited[next] != 0) &#123; // next has not been discovered, normal System.out.println("(" + cur + ", " + next + ") : tree edge"); exeDfs(next); &#125; else &#123; // next has not finished discovery however it has been discovered, then there is a circle System.out.println("(" + cur + ", " + next + ") : back edge"); &#125; &#125; &#125; finished[cur] = ++time; // record finish time &#125;&#125;class UndirectedGraph &#123; private Map&lt;Integer, List&lt;Integer&gt;&gt; adjList; private int maxNodeLabel; private int[] visited; // since undirected graph only has tree edge and back edge // it is not necessary to record the specific visit or finish time of a node // in this case, visited record the state of a node: 0-&gt;undiscovered, 1-&gt;discovered, 2-&gt;finished private int[] father; // since each nodes pair in the undirected graph has two-way edges, // however, unlike directed graph, these two edge do not form a circle, indeed they are the same edge // we should prevent a node visiting its father node and mistake it as a new circle in dfs recursion // use father array to record node's father UndirectedGraph(int[][] list) &#123; adjList = new HashMap&lt;&gt;(); // if input parameter has indicate the number of node, then just need to ust List to represent graph maxNodeLabel = 0; for (int[] li : list) &#123; adjList.computeIfAbsent(li[0], key -&gt; new LinkedList&lt;&gt;()).add(li[1]); adjList.computeIfAbsent(li[1], key -&gt; new LinkedList&lt;&gt;()).add(li[0]); maxNodeLabel = Math.max(maxNodeLabel, Math.max(li[0], li[1])); &#125; visited = new int[maxNodeLabel + 1]; father = new int[maxNodeLabel + 1]; &#125; public void dfs() &#123; for (Integer node : adjList.keySet()) if (visited[node] == 0) father[node] = node; exeDfs(node); &#125; private void exeDfs(Integer cur) &#123; visited[cur] = 1; // the cur node has been discovered for (Integer next : adjList.get(cur)) &#123; if (visited[next] == 1 &amp;&amp; father[cur] != next) &#123; // if next node has been discovered and it is not the cur's father, then we find a new circle System.out.println("(" + cur + ", " + next + ") : back edge"); int tmp = cur; StringBuilder sb = new StringBuilder("Circle: " + cur + " -&gt; "); // use the father[] array to backtrack the whole circle while (father[tmp] != next) &#123; sb.append(father[tmp]).append(" -&gt; "); tmp = father[tmp]; &#125; sb.append(next); System.out.println(sb.toString()); &#125; else if (visited[next] == 0) &#123; // if next has not been discovered, it is a tree edge System.out.println("(" + cur + ", " + next + ") : tree edge"); father[next] = cur; exeDfs(next); &#125; &#125; visited[cur] = 2; &#125;&#125; [参考资料] Introduction to Algorithms https://en.wikipedia.org/wiki/Depth-first_search 判断一个图是否有环]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>CLRS</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++顺序容器小结]]></title>
    <url>%2Fposts%2F716fcce3%2F</url>
    <content type="text"><![CDATA[顺序容器 vector: 支持随机存取，在尾部插入或删除 deque: 双端队列(queue)，支持随机存取，在首尾插入或删除 list: 双向链表，只支持双向顺序访问，在任何位置插入或删除 forward_list: 单向链表，只支持单向顺序访问，在任何位置插入或删除 array: 固定大小数组，支持快速随机访问，不能添加或者删除元素。申明时需指定长度array&lt;type, length&gt; string: 与vector相似的容器，专门用于保存字符，随机访问快，在尾部插入或删除 初始化 C c; 默认初始化 C c{a1, a2, ..}; 列表初始化 C c1(c2); 使用另一容器初始化，容器的类型以及容器中元素的类型都必须匹配 C c(iterator1, iterator2); 使用迭代器范围初始化，只要求容器中元素的类型匹配，对array无效 C c(num); 初始化一个长度为n顺序容器，每个元素初始化为默认值，对array无效 C c(num, value); 初始化一个长度为n的顺序容器，每个元素值为v，对array无效 12345678910111213deque&lt;int&gt; deq; // 默认初始化，容器为emptyarray&lt;int, 3&gt; arr; // array由于其必须指定长度，默认初始化时每个元素被默认初始化vector&lt;int&gt; vec&#123; 1, 2, 3 &#125;; // 列表初始化vector&lt;int&gt; vec2(vec); // 使用另一容器初始化，容器的类型以及容器中元素的类型都必须匹配deque&lt;int&gt; que(vec.begin(), vec.end()); // 使用迭代器范围初始化，只要求容器中元素的类型匹配，对array无效// 只对顺序容器有效list&lt;int&gt; li(3); // C c(n)初始化一个长度为n顺序容器，每个元素初始化为默认值，对array无效string s(3, 's'); // C c(n, v)，初始化一个长度为n的顺序容器，每个元素值为v，对array无效 赋值与交换 容器赋值右侧操作数可以是相同类型的容器或者列表；对于顺序容器来说，如果两个容器类型不同，但是元素类型相同，则可以使用assign相互赋值 c1 = c2; c1 = {a1, a2, ..}; 对array无效 seq.assign(iterator1, iterator2); seq.assign({a1, a2, ...}); seq.assign(num, value); 123list&lt;int&gt; li&#123; 1,2,3 &#125;;vector&lt;int&gt; vec;vec.assign(li.begin(), li.end()); // 如果想让vector的内容与list相等，不能使用vec = li，但是可以用assign 如果想交换容器a,b的内容可以使用swap，除了array，其余容器在使用swap时不进行拷贝赋值，只是交换控制信息，速度非常快 a.swap(b); swap(a, b); 迭代器 begin()指向容器第一个元素，end()指向容器最后一个元素后一个位置，其指示的是一个前闭后开的范围。C++中的迭代器中说明了这样的迭代器区间定义能够轻松地维持容器的不变性 c.begin() c.end() c.cbegin() 只读迭代器 c.cend() c.rbegin() c.rend() c.crbegin() 只读逆向迭代器 c.crend() 插入元素 除了array，其余容器均可动态改变容器大小。以下操作虽然对除array外的所有容器均有效，但是对不同容器性能不同 当将一个对象插入容器时，插入的是对象的拷贝，并不是对象本身 在首尾插入元素 c.push_back(value) 只有array和forward_list不支持，其余vector,deque,list,string都支持 c.push_front(value) 只有list, forward_list, deque支持 1234vector&lt;int&gt; vec;vec.push_back(1);deque&lt;int&gt; deq;deq.push_front(1); 在指定位置插入元素 除了array，其余容器均支持insert。insert共有四种重载，第一个参数均是迭代器，指示了插入的位置，插入的新元素将位于指示的位置（即插入到指示的位置的前一个位置，从而使自己成为指示的位置上的元素），因为从begin()到end()均可以插入。 虽然insert对除array外所有容器均有效，但是vector, deque, string的性能较低 c.insert(iterator, value); 在iterator处插入value c.insert(iterator, num, value); 在iterator处插入num个value c.insert(iterator, it1, it2); 在iterator处插入it1, it2指示的范围里的内容 c.insert(p, {a1, a2, ...}); insert返回值为指向新插入的元素的迭代器 12345vector&lt;int&gt; vec&#123;2&#125;;vec.insert(vec.begin(), 2, 1);vec.insert(vec.end(), &#123; 3, 4 &#125;);list&lt;int&gt; li&#123; 5 &#125;;li.insert(li.begin(), vec.begin(), vec.end()); emplace emplace_back, emplace_front, emplace分别对应了push_back, push_front, insert, 区别在于后三者传入对象的拷贝，emplace传入构造对象的参数，使用这些参数直接在emplace内部初始化对象 push_back只能传入已经构建好的对象，或者是临时对象，容器中存放的是这个对象或者临时对象的拷贝版本，因此会调用拷贝构造函数。 emplace能够接受对象的构造函数的参数列表，直接在容器内部构造对象，省去了拷贝操作。如果emplace接收的参数也是一个对象，则仍然存入该对象的拷贝，此时和push_back是一样的。 注意，emplace传入构造参数前提是对象必须拥有构造函数 c.emplace_back(args) c.emplace_front(args) c.emplace(p, args) 1234567891011121314151617181920212223242526272829303132struct A &#123; int val1; float val2; A(int a, float b) : val1(a), val2(b) &#123;&#125; // 自定义的结构体或者类必须定义构造函数才能在vector中使用empalce&#125;;int main() &#123; vector&lt;int&gt; vec1; vec1.emplace_back(1); vector&lt;vector&lt;int&gt;&gt; vec2; vec2.emplace_back(3, 1); // vector&lt;int&gt;定义了构造函数(num, val), 结果为3个1 [[1,1,1]] // 与vec2.push_back(vector&lt;int&gt;(3, 1))效果是一样的 // vector内并没有定义使用&#123;&#125;的列表构造函数，所以vec2.emplace_back(vector&lt;int&gt;&#123; 1, 2 &#125;)是错误的 vec2.emplace_back(vector&lt;int&gt;&#123;1, 2&#125;); // 当empalce_back参数是一个以构造好的对象或临时对象时，传入该对象的拷贝 vector&lt;pair&lt;int, int&gt;&gt; vec3; vec3.emplace_back(1, 2); // pair被定义了构造函数，[C++中的tuple](https://blog.scloudyy.com/790fc257) vector&lt;tuple&lt;int, int, int&gt;&gt; vec4; vec4.emplace_back(1, 2, 3); // tuple内定义了构造函数，[C++11中tuple的基本用法](https://blog.scloudyy.com/posts/da0443a/) vector&lt;A&gt; vec5; vec5.emplace_back(2, 3.0); // 自定义的结构体定义了构造函数，可以使用empalce直接传入构造参数&#125; 删除元素 c.pop_back(); 删除最后一个元素，返回void，如果容器为空会报错 c.pop_front(); 删除第一个元素，返回void，，如果容器为空会报错 c.erase(iterator); erase返回最后一个被删除的元素的后一个元素的迭代器 c.erase(iterator1, iterator2); pop_back不支持forward_list，pop_front不支持vector, string 获取元素 c.back(); 返回最后一个元素的引用，如果容器为空会报错 c.front(); 返回第一个元素的引用，如果容器为空会报错 c[n]; c.at(n); at()比下标索引更为安全，如果越界会抛出out_of_range异常 关系比较 所有容器都支持 ==, != 顺序容器支持 &lt;, &lt;=, &gt;, &gt;= 只有容器中的元素支持相依比较操作时，容器才能进行关系比较 比较规则： 如果两个容器具有相同的长度而且所有元素都相等，则两个容器相等 如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则较短的容器小于另一个容器 如果两个容器不是对文的初始子序列，则它们的比较结果取决于第一个不相等的元素 容器大小 size() 容器当前容纳的元素数量（forward_list无效） empty() 是否为空。建议判断是否为空统一使用empty而非size()==0，比如在判断二维数组时，如果其为空，就不能再使用vec[0].size()==0这种操作 max_size() 容器所能容纳的元素数量最大值 resize 对array外所有容器均有效。如果resize后容器小于当前容器，则从后往前删除 c.resize(num); 将容器resize为num大小 c.resize(num, value); 将容器resize为num大小，任何增添的元素值为value [参考资料] C++ Primer https://blog.csdn.net/bonchoix/article/details/8061994 https://blog.csdn.net/kesalin/article/details/24265303]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>vector</tag>
        <tag>array</tag>
        <tag>sequence container</tag>
        <tag>deque</tag>
        <tag>list</tag>
        <tag>forward_list</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB联通域操作小记]]></title>
    <url>%2Fposts%2Fd4d566%2F</url>
    <content type="text"><![CDATA[图像处理中一种很常见的方式就是将图像转换为二值图，然后对二值图中的联通域进行操作，特别像是图像分割等算法。当时年轻不懂事，竟然手写广搜来查找联通域，后来才知道MATLAB中与联通域相关的函数可谓是应有尽有 实用函数 bwlabel 基本用法： 1[L, num] = bwlabel(BW,conn); bwlabel将二维的二值图BW中每个联通域标记上不同的标签，标签从1开始计数，到num为止，num为BW中联通域的总数。conn为判断联通域的方法，默认为8联通 regionprops 基本用法： 1stats = regionprops(L, properties); regionprops用于测量label矩阵L中每一个label区域的一系列属性。其返回值是一个长度为label总数的结构体数组，每个field对应一个label，结构体中存放了相应属性的度量 需要测量的属性由properties指定。properties 可以是由逗号分割的属性的字符串列表，'all' 或者 'basic'。如果 properties 等于字符串 'all'，则所有下述字串列表中的度量数据都将被计算。如果 properties 没有指定或者等于 'basic'，则属性: 'Area', 'Centroid', 和 'BoundingBox' 将被计算。其中用得比较多的就是'Area'，其反应了label区域包含的像素个数 有了每个区域的属性后，就可以结合ismember函数提取label矩阵中符合特定条件的区域，其基本操作为： 1bw = ismember(A, B); ismember函数判断矩阵A的元素是否为集合B中的成员，返回一个与A大小相同的逻辑矩阵。在操作时一般使用find将stats中符合特定属性条件的区域的label值（filed值）取出作为集合B，从而提取矩阵A中相应区域 1bw = ismember(label, find([stats.Area] &gt; 500)); % 提取label中联通域面积大于500个像素的区域 bwarea 基本用法： 1area = bwarea(BW); 估计二值图像BW中对象的面积。注意，该面积和二值图像中对象的像素数目不一定相等 bwboundaries 基本用法： 1B = bwboundaries(BW,conn); 获取二值图中对象的轮廓，B是一个P×1的cell数组，P为对象个数，每个cell 是Q×2的矩阵，对应于对象轮廓像素的(y, x)坐标。 如果对象在边界，则边界也会被标为轮廓 实际应用 首先创建一张具有六个大小各异的联通域的二值图像，用于测试 1234567src = zeros(800, 800);src(20:220, 20:220) = 1;src(400:420, 400:420) = 1;src(600:700, 600:700) = 1;src(500:700, 50:500) = 1;src(300:320, 700:720) = 1;src(1:100, 700:800) = 1; 获取这张二值图的label图像，以及label的属性 12label = bwlabel(src);stats = regionprops(label, 'basic'); 去除面积小于阈值的联通域 去除联通域面积小于500个像素的区域 使用专用函数bwareaopen 1bw1 = bwareaopen(src, 500); bwareaopen(BW, P, conn)删除二值图像BW中联通区域小于P个像素的区域，conn是判断联通域的方式，默认情况下使用8邻域 通用方法 1bw2 = ismember(label, find([stats.Area] &gt;= 500)); 保留面积最大或最小的两个联通域 12[v, index]=sort([stats.Area],'descend'); % 对stats的Area域进行排序bw3 = ismember(label, index(1:2)); % 保留面积最大的两个联通域 1bw4 = ismember(label, index(end-1:end)); % 保留面积最小的两个联通域]]></content>
      <categories>
        <category>technology</category>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB: 告别for循环]]></title>
    <url>%2Fposts%2Fbba64e0%2F</url>
    <content type="text"><![CDATA[MATLAB不是C语言，名字中都出现了MAT，在操作MAT时怎么还能用for循环！ 在C语言的思路中，如果要对一个二维矩阵每个元素进行某种操作，似乎唯一的方法就是写两层for循环遍历整个矩阵。但是在MATLAB中，这种写法不仅代码量大，运行效率也极低。但是这绝不代表MATLAB时一门低效的语言。相反，MATLAB对矩阵操作进行了大量的优化，只要使用得当，不仅写法简便，效率也会高得出奇 矩阵赋值 让MATLAB操作矩阵变得便利的基础之一就是：MATLAB中可以使用索引对整个矩阵进行操作。这个索引可以是与矩阵相同大小的逻辑矩阵，也可以是元素的位置向量 123a = zeros(2,2);b = [true, true; false, false]; % 使用逻辑矩阵对整个矩阵进行操作a(b) = 1; 123a = zeros(2,2);b = [1， 3]; % 使用元素位置向量对整个矩阵进行操作a(b) = 1; 两种方式得到的a的值均为 a = 1 1 0 0 使用索引的操作，从本质上改变了如果要对整个矩阵进行操作必须进行for循环遍历的思维方式。这种使用索引的操作方式配合各种MATLAB函数，能够创造无尽可能 find 假设我们遇到了这个问题：已知有四张二值图 B1，B2，B3，B4，要对它们进行如下操作得到 R \[ R=(R_1\bigcap R_2)\bigcup (R_1\bigcap R_3)\bigcup (R_1\bigcap R_4)\bigcup (R_2\bigcap R_3)\bigcup (R_2\bigcap R_4)\bigcup (R_3\bigcap R_4) \] 如果使用C语言的思想，用for循环来实现的话那么代码量将是巨大的。但换一种思路，依照MATLAB面向矩阵的思路，配合MATLAB中一些神函数就能在几行代码内实现这么复杂的并集交集操作，比如find函数 find函数返回矩阵中满足特定条件的元素的位置索引向量，使用find我们可以方便地找到我们希望进行操作的元素，并对其进行赋值或者进一步操作。 1234567891011R = zeros(size(R1));findR1 = find(R1==1);findR2 = find(R2==1);findR3 = find(R2==1);findR4 = find(R4==1);R(union(union(union(union(union( ... intersect(findR1, findR2), intersect(findR1, findR3)), ... intersect(findR1, findR4)), ... intersect(findR2, findR3)), ... intersect(findR2, findR4)), ... intersect(findR3, findR4))) = 1; 上面的代码中，我们将输入矩阵中值为1的元素（即我们希望进行操作的元素）的位置索引赋给findR1 - findR4，然后对这些位置索引进行求交求并操作，并将结果作为R的索引对其进行赋值 bsxfun 使用find对矩阵进行求交求并操作仍然比较复杂，先要对位置索引进行交并操作，然后才能对矩阵进行赋值，能不能直接在矩阵上一步到位地达到我们的目的？ 这里推出我们第二个神级函数bsxfun。bsxfun可以对两个矩阵中的每个元素进行相同操作，并且其内置了很多实用的函数句柄，比如or与and，使用bsxfun一行代码就可以完成任务 123456R = bsxfun(@or, bsxfun(@or, bsxfun(@or, bsxfun(@or, bsxfun(@or, ... bsxfun(@and, R1, R2), bsxfun(@and, R1, R3)), ... bsxfun(@and, R1, R4)) ,... bsxfun(@and, R2, R3)), ... bsxfun(@and, R2, R4)), ... bsxfun(@and, R3, R4));]]></content>
      <categories>
        <category>technology</category>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>bsxfun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 最优连续子数组]]></title>
    <url>%2Fposts%2Fb0e42d44%2F</url>
    <content type="text"><![CDATA[53. Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. 123&gt; Input: [-2,1,-3,4,-1,2,1,-5,4],&gt; Output: 6&gt; Explanation: [4,-1,2,1] has the largest sum = 6. 划分阶段：问题的规模与数组长度n有关 从子问题出发定义状态： 设当前阶段为i，如果状态定义为该阶段下连续子串长度，最优状态时最长连续子串长度，当进入i+1阶段时，两阶段的差异在与最后一个元素，很明显，最后一个元素的加入不会对阶段n最优状态的选择产生任何影响，其无后效性。但是，题目要求子串连续，在上述状态定义下我们不知道最长子串末尾元素在哪里，更不知道其余状态的信息，那么进入下一个阶段后，第i+1个元素是否应该纳入最长连续子串无从判断，两个阶段之间难以关联。 之所以关注最后一个元素，是因为其是两个阶段之间的差异点，也是连接点，为了满足连续的条件，最后一个元素势必需要与前一个元素比较才能将两个阶段相连。所以我们将状态 d(i) 定义为阶段 i 下以第 i 个元素结尾的最长连续子串长度。这个状态定义限制更大，我们需要追踪最大值，但是其能够让相邻阶段之间产生关联。 d(i)是阶段i下的一个状态，并不是真正的最优状态，而是以元素i为结尾的子串这个特殊条件下的最佳状态。由于其并灭有保存，所以需要手动追踪最大值 状态转移方程： \[d(i) = \begin{cases} d(i-1)+1 &amp; \text{ if } nums(i) &gt;= nums(i-1) \\ 1 &amp; \text{ otherwise } \end{cases}\] 当前最优状态只与上一个阶段最优状态有关，贪心 152. Maximum Product Subarray **** Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. 123&gt; Input: [2,3,-2,4]&gt; Output: 6&gt; Explanation: [2,3] has the largest sum = 6. 划分阶段：问题的规模与数组长度n有关 从子问题出发定义状态：由于问题要求最优数组连续，在问题规模扩大的过程中，前后两个阶段的连接点在于最后一个（新加入）的元素与前一个（上一阶段的最后）元素之间的关系，所以状态需要与最后一个元素有关。同时考虑正负值与零三者之间的特殊性，最小的负值乘以下一阶段加入的负值后很可能乘积是最大的正值；无论多大的正值与负值，如果下一阶段加入的元素是零，最大连续都会被打断。所以对于阶段i，需要记录两个最优状态：\(max_v(i)\)表示最大值， \(min_v(i)\)表示最小值。同时使用额外变量追踪最大值。 状态转移方程： \[max_v(i) = max(nums(i) * max_v(i-1), nums(i) * min_v(i-1))\] \[min_v(i) = min(nums(i) * max_v(i-1), nums(i) * min_v(i-1))\] 当前最优状态只与上一个阶段最优状态有关，贪心]]></content>
      <categories>
        <category>technology</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dynamic programming</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解动态规划]]></title>
    <url>%2Fposts%2Ff8c8bd2a%2F</url>
    <content type="text"><![CDATA[理解动态规划 由于计算机本质是一个 状态机，存储的数据与变量构成了当前 状态。在使用计算机解决问题时，使用变量存储用于描述问题的数据其实就是将问题解构成了计算机中的状态为计算机中的状态（空间复杂度），如果由初始的变量求解出最终的结果其实就是从初试状态出发 转移 到最终状态（时间复杂度） 由于当前状态转移到下一个状态时需要做出 决策，不同的决策会有不用转移状态，同一个时刻下所有可能的状态的集合称为 阶段。一个状态对应一个阶段，一个阶段可以有很多不同的状态，一般只关心一个阶段的最优状态。 阶段n的状态一旦确定，那么阶段n以后的状态转移只和阶段n有关，而和这个阶段n以前的状态无关，并且阶段n以后的状态在计算时不会影响阶段n的状态，这叫 无后效性。因为进入下一个阶段n+1后，新阶段n+1中加入的元素不会对上一阶段n的状态与决策产生任何影响，所以我们不必关心上一个阶段n的状态是怎么出现的，更不必考虑这个状态的更早之前一个状态是什么 阶段n可以理解为规模为n的子问题，状态就是解。阶段是一个集合，即阶段n包含了规模为n的子问题的所有解，其最优状态就是最优解。从当前阶段中的状态转移到下一阶段中的状态，就是从当前子问题的出发，计算得到后一个子问题（规模更大）的解。 动态规划指每个阶段的最优状态可以从之前某几个阶段的最优状态直接计算得到（最优子结构）而不管之前这个状态是如何得到的（无后效性） 动态规划问题最核心的是前两步：定义最优解的结构，其实就是拆分问题，对问题进行状态的定义（在定义状态时建议从子问题，小规模的问题出发进行思考）；描述最优解与子问题最优解之间的关系，就是定义状态转移方程 例： 最长上升序列LIS中，界定阶段：问题规模与数组长度有关，一维DP问题。状态为 \(v[i]\)，代表以第\(i\)个元素结尾的LIS长度，状态转移方程为 \(v[i] = max{1, v[j] + 1},j &lt; i, A[j] &lt;= A[i]\)。有些数组问题在表示状态时使用两侧变化的数组 \(v[i,j]\)，有些只有一侧变化 \(v[0,j]\)，这只是根据问题形式对状态的表示不同，两者的问题规模都只与数组长度有关，都是一维DP问题 背包问题中，界定阶段：问题规模与背包体积与宝石数组长度有关，二维DP问题。状态为 \(v[i,j]\)，表示前i个宝石装到剩余体积为j的背包里能达到的最大价值，状态转移方程为 \(v[i,j] = max{v[i-1,j], v[i-1, j-W[i]] + P[i] (j &gt;= W[i])}\) 动态规划更理论的求解步骤 划分阶段：划分阶段对于多阶段决策问题来说非常重要，因为其决定了应该怎么界定子问题的规模 确定状态：使用状态表示问题在各个阶段的各种客观情况，一般从规模较小的子问题出发进行思考比较便捷。定义的状态首先要满足无后效性，即在下一阶段问题规模扩大后，新加入的元素不会对本阶段的状态造成任何影响；其次，定义的状态能够使相邻阶段产生关联，即下一阶段的最优状态能够从本阶段计算得到，为了满足这一条件，某些问题往往会对状态的定义做出限制，比如最优连续子数组。一般来说，状态存储了小规模问题的结果，题目问什么状态就设什么，问最优解状态就设为最大最小值，问是否存在状态就设为是否存在，问计数状态就为count 确定状态转移方程：根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程，即如何通过小规模问题的状态求大规模问题的状态 寻找边界条件：递推式的终止条件或边界条件。初始化，最极限的小状态，以及答案，最大的状态 动态规划与其他算法的区别 知乎上的总结： 动态规划：每个阶段的最优状态可以从之前某几个阶段的某个或某几个状态直接计算得到（最优子结构）而不管之前这个状态是如何得到的（无后效性） 贪心：每个阶段的最优状态可以仅由上一个阶段的最优状态计算得到 递推：每个阶段只有一个状态 搜索：每个阶段的最优状态是由之前所有阶段的状态的组合得到的 [参考资料] https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/ https://www.hawstein.com/posts/dp-knapsack.html https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html https://www.zhihu.com/question/23995189/answer/35324479 https://www.zhihu.com/question/23995189/answer/35429905]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的迭代器]]></title>
    <url>%2Fposts%2Fa781e8a%2F</url>
    <content type="text"><![CDATA[迭代器与指针的区别 迭代器可以说是广义的广义的指针，支持指针的许多标志性操作，比如使用++,--来指向下一个或上一个元素，使用解引用(dereference)获取元素值，但是其并不是普通的指针。 1234vector&lt;int&gt; vec = &#123;1, 2&#125;;for (auto i = vec.begin(); i != vec.end(); i++) &#123; // 通过++使迭代器指向下一个元素 *i = 3; // 使用dereference获取元素值&#125; 与指针一样，如果迭代器作为参数传入函数，在函数内改变迭代器所指向的值会影响外部；而在函数内改变迭代器本身并不会影响外部，除非传入引用 1234567891011void change(vector&lt;int&gt;::iterator it, vector&lt;int&gt;::iterator &amp;it2) &#123; *it = 10; it++; it2++;&#125;int main() &#123; vector&lt;int&gt; arr&#123; 1, 2, 3 &#125;; auto it = arr.begin(), it2 = arr.begin(); change(it, it2); // 此时arr的值为10, 2, 3, it仍然指向第一个元素10，而it2指向第二个元素2&#125; iterator vs. range for C++11中引入了range for特性，使得for语句中可以方便的遍历整个序列 12345vector&lt;int&gt; vec = &#123;1, 2&#125;;for (auto i : vec) &#123; i = 3; // 返回的i并不是迭代器，而是int，并且没有加引用不能改变vec中的值&#125;// vec中元素值仍然为[1, 2] 但是又两点需要特别注意 虽然range for实现时使用了迭代器，但是其返回值并不是迭代器，而是序列中元素类型。上例中vector中元素类型时int，所以range for返回类型就是int。 range for将vector中元素的值拷贝入变量i，所以直接对变量i赋值不能改变vector中的值。如果想改变序列中的元素值，需要把循环变量定义成引用类型： 12345vector&lt;int&gt; vec = &#123;1, 2&#125;;for (auto &amp;i : vec) &#123; i = 3; // 要改变vector中的元素值，要将i定义为引用&#125;// 现在vec中的元素值为[3, 3] begin() &amp;&amp; end() 因为STL中的begin和end定义的是一个半开放区间[begin, end)，end()是最后一个元素的后一个位置。这里要注意，end()只能用于比较，不能解引用，还有虽然end()是指向容器最后一个元素的后一个位置，但是并不代表我们的代码中迭代器可以超出容器范围 使用 begin() 与 end() 可以保持invariants： 1. 数组元素个数始终等于end()-begin()； 2. 空数组的起点指针等于终点指针，判断是否到尾部: begin() != end()。在循环的条件判断中，迭代器比较操作尽量比较改用!=操作，因为有些容器的迭代器不支持比较操作，但所有容器的迭代器都支持!=，这样写有助于代码一致性。 3. 迭代器加上或减去一个整型值n将得到一个新的迭代器，其位于源迭代器的前(后)n个元素位置。迭代器相减得到的是两迭代器的距离，类型为iterator::difference_type 迭代器关系操作符 只有当迭代器都指向同一容器，且未超出最后一个元素下一个位置时可以进行比较 “比较”是指比较迭代器在容器中的位置关系 !=, == 比较是所有迭代器都支持的，所以在for循环条件判断时建议使用这种方式，保持代码一致性 &lt;, &lt;=, &gt;, &gt;= 这四个关系操作符值适用于 vector 和 deque 容器 前进后退 迭代器it前进后退一个单位可以简单的用--, ++，但是有时我们只是想知道前后元素的值但并不想代表当前迭代器的位置，或者想一次前进后退多个位置，这是迭代器和普通的指针行为不同，*(it+1)这种写法是错误的，迭代器没有定义+-操作。 使用next, prev 1234567list&lt;int&gt; l&#123; 1,2,3,4 &#125;;list&lt;int&gt;::iterator it = l.begin();list&lt;int&gt;::iterator it2 = next(it, 2); // it2指向'3'// it2 = it + 2; errorlist&lt;int&gt;::iterator it3 = prev(it2, 2); // it3指向'1'auto a = *next(it, 1); // a = b，但是a这种写法并不会改变当前迭代器的位置auto b = *(++it); 逆向迭代器 容器定义了最后一个元素的后一个位置(end())，但是没有定义第一个元素的前一个位置，所以如果想在普通迭代器begin(),end()的基础上使用同样的逻辑反向遍历容器变得非常困难（反向遍历时结尾的开区间没有被定义）。因此，STL定义了逆向迭代器，专门用于反向遍历容器。 尽管STL专门设置了逆向迭代器，但是容器第一个元素的前一个位置仍然没有被定义的，所以为了与普通迭代器在操作概念上保持一致，逆向迭代器与普通迭代器在内部实现上有“逻辑位置”与“物理位置”的区别。“逻辑位置”指迭代器解引用时所指向的元素，“物理位置”指迭代器实际指向的位置。 普通迭代器的“逻辑位置”与“物理位置”是一致的，而逆向迭代器的“逻辑位置”比物理位置往左偏一个元素。逆向迭代器这样的实现方式能够让rend()的“逻辑位置”指向第一个元素的前一个位置，从而让逆向与普通迭代器具有一样的操作概念，即定义了一个半开放区间。 用户在编码时，迭代器面向用户的都是其“逻辑位置”，“物理位置”只有正逆迭代器相互转换时用到，所以我们可以简单地将逆向迭代器的位置理解为比正向迭代器左偏一个元素。使用.based()将逆向迭代器转为正向迭代器：riterator.base()，得到的元素是riterator右侧的一个元素；相反，使用::reverse_iterator(iterator)将正向迭代器转为逆向迭代器，其得到的是iterator左侧的一个元素 c.rbegin() c.rend() c.crbegin() 只读逆向迭代器 c.crend() 12345678910111213vector&lt;int&gt; vec&#123;1,2,3,4,5,6,7,8&#125;;// 正向逐个删除vector中的元素for (auto it = vec.begin(); it != vec.end();) &#123; it = vec.erase(it);&#125;vec = &#123; 1,2,3,4,5,6,7,8 &#125;;// 逆向逐个删除vector中的元素// 由于erase只接受正向迭代器，所以需要将逆向迭代器转为正向迭代器传给erase，然后再将erase返回的迭代器转为逆向迭代器进行下一次循环// 由于正向迭代器比逆向迭代器右偏一个元素，所以需要prev(it.base())以得到指向相同位置的正向迭代器（先it.base()在prev()防止越界）// erase返回被删除的元素的下一个元素，经::reverse_iterator转换得到的逆向迭代器指向当前位置的上一个元素，所以::reverse_iterator(erase())结合正好能够返回悲伤出的元素的上一个元素，使得逆向删除能够继续for(auto it = vec.rbegin(); it != vec.rend();) &#123; it = vector&lt;int&gt;::reverse_iterator(vec.erase(prev(it.base())));&#125;]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11中tuple的基本用法]]></title>
    <url>%2Fposts%2Fda0443a%2F</url>
    <content type="text"><![CDATA[C++11引入的tuple是一个允许存放任意数量任意类型的容器，可以用来代替简单的结构体，其包含在头文件中 基本操作 tuple&lt;v1, v2&gt; t(v1, v2) ： 声明并初始化一个tuple 1std::tuple&lt;int, float&gt; t(1, 1.5); make_tuple(v1, v2) ： 返回一个通过指定元素类型初始化后的tuple 12std::tuple&lt;int, float&gt; t;t = std::make_tuple(1, 1.5); tie(v1, v2) ： 解包tuple，一次取出tuple中的值 1234std::tuple&lt;int, float&gt; t(1, 1.5);int a;float b;std::tie(a, b) = t; get(tuple) ： 获取tuple中特定位置的元素 12std::tuple&lt;int, float&gt; t(1, 1.5);int a = get&lt;0&gt;(t); tuple_cat(tuple1, tuple2) ： 连接两个tuple 123std::tuple&lt;int, float&gt; t1(1, 1.5);std::tuple&lt;string, bool&gt; t2("str", true);auto t3 = std::tuple_cat(t1, t2); tuple_element&lt;i, tupleType&gt;::type ： 获取tuple中特定元素的数据类型 12std::tuple&lt;int, float&gt; t1(1, 1.5);std::tuple_element&lt;0, decltype(t1)&gt;::type a = std::get&lt;0&gt;(t1); tuple_size::value ： 获取tuple的元素个数 12std::tuple&lt;int, float&gt; t1(1, 1.5);auto num = std::tuple_size&lt;decltype(t1)&gt;::value; 应用 由于tuple可以容纳任意数量任意类型的容器，在C++中比较给力的应用场景之一就是函数返回多个值。 123456789101112131415#include &lt;tuple&gt;#include &lt;string&gt;using namespace std;using return_type = tuple&lt;int, string&gt;; // 将类型为&lt;int, string&gt;的元组定义别名return_typereturn_type test(void) &#123; return make_tuple(1, "str"); // 返回一个元组&#125;int main() &#123; auto res_test = test(); tuple_element&lt;0, decltype(res_test)&gt;::type res1; // 获取tuple第一个元素的类型 std::tie(res1, ignore) = res_test; // 解包时如果有不想获取的元素可以用std::ignore替换那个元素 auto res2 = get&lt;1&gt;(res_test); // 使用get&lt;&gt;()方法获取元素&#125;]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
        <tag>tuple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法 Greedy Algorithm]]></title>
    <url>%2Fposts%2Fd44bb4df%2F</url>
    <content type="text"><![CDATA[贪心算法 贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。 贪心算法 vs 动态规划 动态规划在做决策时需要根据子问题的最优解来决定当前哪个决策时最优的，所以动态规划通常采用自底向上的方法求解。相反，贪心算法只根据当前状态做出决策，其最优决策与子问题无关，所以贪心算法自顶向下求解，可以不解决任何子问题就做出第一个决策。如果可以证明当前决策既不受之前决策的影响，也不影响后续决策，则应该使用贪心算法 设计贪心算法的步骤 对于存在最优子结构的优化问题（原问题的最优解包含子问题的最优解），判断使用动态规划还是贪心算法，参考“贪心算法 vs 动态规划” 做出决策，并且只剩下一个子问题 证明原问题总是有一个最优解是贪心选择得到的，从而证明贪心选择的安全性 说明做出贪心选择之后，剩余的子问题具有一个性质：如果将子问题的最优解和所做的贪心选择联合，可以得到原问题的一个最优解 [参考资料] Introduction to Algorithms https://blog.csdn.net/qq_32400847/article/details/51336300]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>CLRS</tag>
        <tag>greedy algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵链 Matrix Chain]]></title>
    <url>%2Fposts%2Fffb8ca73%2F</url>
    <content type="text"><![CDATA[问题描述 由于矩阵乘法满足结合律，所以对于连续相乘的矩阵链，可以使用不同的计算次序求解矩阵积。不同的相乘次序所需要的总元素相乘量是不同的，这种计算次序可以用加括号的方式来确定。 完全括号化指：如果单个矩阵或者两个完全括号化的矩阵积都被括号包括，则这个矩阵链是完全括号化的。 矩阵链问题描述： 对于给定的具有 \(n\) 个矩阵的矩阵链：\(&lt;A_1, A_2, ..., A_n&gt;\)，其中 \(A_i\) 的维度为 \(p_{i-1}*p_i\)。求矩阵链的完全括号化方式，使得元素相乘次数最少。 规模为 \(n\) 的矩阵链有两个子问题，需要进行 \(n-1\) 次决策得到最优解 动态规划 最优解的结构 动态规划第一步时寻找问题的最优子结构，之后使用子结构的解构造原问题的解。 矩阵链问题的最优子结构可以被描述为：设矩阵链 \(A[1, n]\) 被分割为两个子链 \(A[1, k]\) 与 \(A[k+1, n]\)，则这两个子链都必须具有最优完全括号化方式，否则将它们合并时原问题的解就不是最优的。这两个子链是矩阵链问题的一个规模较小的实例。所以矩阵链问题存在最优子结构。（动态规划标志之一：存在最优子结构） 递归定义最优解的值 对于矩阵链 \(A[i, j]\) ，假设在 \(k\) 处将其分割为两个子链 \(A[i, k]\) 与 \(A[k+1, j]\)，则这种分割法的最优计算消耗为两个子链各自的最小的计算消耗之和，再加上两个子链的结果矩阵相乘的计算消耗。遍历所有 \(k\) 找到原问题最优解 递推关系如下： \[ m[i,j] = \left\{\begin{matrix} 0 &amp; i = j\\ min_{i\leqslant k&lt;j}{m[i,k] + m[k+1,j]+p_{i-1}p_kp_j} &amp; j &lt; j \end{matrix}\right. \] 计算最优解的值 递归求解矩阵链最优解时，会发现递归树上子问题出现多次。需要使用表来记录重叠的子问题的结果，避免重复计算（动态规划标注之二：子问题重叠） 伪代码 设 \(p\) 为矩阵链的纬度向量，矩阵\(A_i\)维度为\(p_{i-1}*p_i\)。 123456789101112131415MATRIX-CHAIN-ORDER(p) n = p.length - 1 let m[1 to n, 1 to n] and s[1 to n, 1 to n] to be new tables for i = 1 to n m[i, i] = 0 for l = 2 to n for i = 1 to n - l + 1 j = i + l -1 q = MAX for k = i to j - 1 if m[i,k] + m[k+1,j] + p[i-1] * p[k] * p[j] &lt; q q = m[i,k] + m[k+1,j] + p[i-1] * p[k] * p[j] s[i,j] = k m[i,j] = q return m and s 重构解 使用递归过程中保存的最佳分割选择s重构最终的解 伪代码 12345678PRINT-OPTIMAL-PARENS(s, i, j) if i == j print "Ai" else print "(" PRINT-OPTIMAL-PARENS(s, i, s[i,j]) PRINT-OPTIMAL-PARENS(s, s[i,j] + 1, j) print ")" 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;vector&gt;#include &lt;tuple&gt;#include &lt;iostream&gt;#include &lt;limits&gt;using namespace std;using ret_type = tuple&lt;vector&lt;vector&lt;size_t&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt;;const size_t MAX = numeric_limits&lt;size_t&gt;::max();ret_type matrix_chain_order(vector&lt;size_t&gt; dims) &#123; const size_t dim = dims.size() - 1; vector&lt;vector&lt;size_t&gt;&gt; value(dim, vector&lt;size_t&gt;(dim, 0)); vector&lt;vector&lt;int&gt;&gt; piece(dim, vector&lt;int&gt;(dim, 0)); int i, j, k, p; for (int len = 2; len &lt;= dim; len++) &#123; for (i = 0; i &lt;= dim - len; i++) &#123; j = i + len - 1; auto q = MAX; for (k = i; k &lt; j; k++) &#123; auto tmp = value[i][k] + value[k+1][j] + dims[i] * dims[k+1] * dims[j+1]; // i.row k.col j.col if (tmp &lt; q) &#123; q = tmp; p = k; &#125; &#125; value[i][j] = q; piece[i][j] = p; &#125; &#125; return make_tuple(value, piece);&#125;void print_optimal_parens(vector&lt;vector&lt;int&gt;&gt; piece, int i, int j) &#123; if (i == j) &#123; cout &lt;&lt; "A" &lt;&lt; i; &#125; else &#123; cout &lt;&lt; "("; print_optimal_parens(piece, i, piece[i][j]); print_optimal_parens(piece, piece[i][j] + 1, j); cout &lt;&lt; ")"; &#125;&#125;int main(int argc, char** argv) &#123; vector&lt;size_t&gt; dims&#123; 30, 35, 15, 5, 10, 20, 25 &#125;; const int dim = dims.size() - 1; vector&lt;vector&lt;size_t&gt;&gt; value; vector&lt;vector&lt;int&gt;&gt; piece; tie(value, piece) = matrix_chain_order(dims); print_optimal_parens(piece, 0, dim - 1);&#125; 代码托管于github: scloudyy/CLRS [参考资料] Introduction to Algorithms]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dynamic programming</tag>
        <tag>CLRS</tag>
        <tag>matrix chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的二维数组]]></title>
    <url>%2Fposts%2F41ca8087%2F</url>
    <content type="text"><![CDATA[使用new构建二维数组 二维数组的内存存取方式和普通的一维数组是一样的，只不过当要取某个元素时编译器会根据维度大小计算该元素在内存中的位置，从而将问题转换为一维数组的存取。但是在这片连续内存中并没有任何标志指明二维数组两个维度的长度分别是多少，所以在初始化二维数组时，必须明确指定第二维的长度，第一维编译器可以根据元素个数自动推导 1int arr[][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;; 这里要注意，使用new动态开辟数组的内存所使用的指定数组长度的参数必须是constexpr，而不能是普通变量，包括const变量。（const指值不变，初始化可以延迟到运行时；constexpr指编译期就确定值，必须在编译时进行初始化） 二维数组作为参数传入函数 方法一： 在函数定义时就写明二维数组第二维的长度 123void fun1(int arr[][3], int rows) &#123; cout &lt;&lt; arr[0][1];&#125; 优点是在函数内部处理时依然能以二维数组的形式处理；缺点是二维数组第二维长度在函数定义时被定死，缺乏灵活性 方法二： 传入指针，当作一维数组来处理 12345void fun(int*arr,int rows,int cols)&#123; cout&lt;&lt;*(arr+0*iRows+2);&#125;fun((int*)a,2,3); // 需要将二维数组强制类型转换为int *指针 变长二维数组 C++中指定数组维度的参数必须是constexpr，所以如果希望开辟以参数作为维度的二维数组最好使用vector 12int dim = 2;vector&lt;vector&lt;int&gt;&gt; 2Darray(dim, vector&lt;int&gt;(dim， 0)); // 创建维度为[dim, dim]的二维数组，初始化为0矩阵]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>vector</tag>
        <tag>new</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[钢管分割 Rod Cutting]]></title>
    <url>%2Fposts%2F3252a2b8%2F</url>
    <content type="text"><![CDATA[问题描述 将一条长度为 \(n\) 的钢管切为长度为 \(i_1, i_2, ..., i_n\) 的小钢管，长度为 \(n\) 的钢管对应的价格为 \(p_n\)，求利润最大的分割方式（如果长度 \(n\) 对应的价格足够大，那么就不需要分割） Length \(i\) 1 2 3 4 5 6 7 8 9 10 Price \(p_n\) 1 5 8 9 10 17 17 20 24 30 最优子结构 optimal substructure 如果原问题的最优解包含了两个可以独立求解的子问题的最优解，则这种问题存在 最优子结构。 在钢管分割问题中，求解规模为n的原问题的最优解，可以转化为求解并合并子问题的最优解。 例如，在分割长度为 \(n\) 的钢管时，“第一刀”将钢管分割为长度为 \(i\) 与 \(n - i\) 两条子钢管。“第一刀”后，左侧长度为 \(i\) 的钢管对应的价格已经确定因为其不会再被分割，右侧长度为 \(n - i\) 的子钢管将被继续分割，可以将其视为独立的规模更小的钢管问题递归求解。 切割长度为 \(n\) 的钢管只有一个规模为 \(n-i\) 的子问题，需要进行 \(n\) 次决策后才能决定哪个子问题能够得到最优解 设长度为n的钢管最大利润为\(r_n\)，该问题可以被描述为： \[ r_n = max(p_i + r_{n-i}) \] 自顶向下的递归方法 为了实现上述算法思想，直接对输入的规模为n的问题调用递归进行求解 伪代码： 1234567CUT-ROD(p, n) if n == 0 return 0 q = -MAX for i = 1 to n q = max(q, p[i]+CUT-ROD(p, n-i)) return q 但是直接对规模为n的原文题调用递归，逐层分解，会存在大量的冗余计算。由于求解子问题的递归独立进行，在求解规模为3与规模为4的子问题时，都需要将递归求解规模为2的子问题，这样规模为2的子问题就被求解了两次。 Introduction to Algorithms p.364 从问题规模为4的递归树可以直观的看到，如果直接从原规模问题开始分解，很多子问题都被重复求解了 复杂度 时间复杂度: \(T(n) = \Theta(2^n)\) 使用动态规划 使用动态规划降低计算冗余，通过存储子问题的解使每个子问题只被求解一遍 带存储的自顶向下方法 伪代码 1234567891011121314151617MEMOIZED-CUT-ROD(p, n) let r[0, r] to be a new array for i = 0 to n r[i] = -MAX return MEMOIZED-CUT-ROD-AUX(p, n, r)MEMOIZED-CUT-ROD-AUX(p, n, r) if r[n] &gt;= 0 return r[n] if n == 0 q = 0 else q = -MAX for i = 1 to n q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n - i, r)) r[n] = q return q 实现 123456789101112131415161718192021int memoized_cut_rod_aux(const vector&lt;int&gt; price, const int length, vector&lt;int&gt; &amp;revenue) &#123; if (revenue[length] &gt; 0) &#123; return revenue[length]; &#125; int q = -1; if (length == 0) &#123; q = 0; &#125; else &#123; for (int i = 1; i &lt;= length; i++) &#123; q = max(q, price[i] + memoized_cut_rod_aux(price, length - i, revenue)); &#125; &#125; revenue[length] = q; return revenue[length];&#125;int memoized_cut_rod(const vector&lt;int&gt; price, const int length) &#123; vector&lt;int&gt; revenue(length + 1, -1); return memoized_cut_rod_aux(price, length, revenue);&#125; 代码托管于github: scloudyy/CLRS 自底向上方法 伪代码 123456789BOTTOM-UP-CUT-ROD(p, n) let r[0,n] to be a new array r[0] = 0 for i = 1 to n // 子问题1 to n q = -MAX for j = 1 to i // 子问题下切割方式1 to i q = max(q, p[j] + r[i - j]) r[i] = q return r[n] 实现 123456789101112int bottom_up_cut_rod(const vector&lt;int&gt; price, const int length) &#123; vector&lt;int&gt; revenue(length + 1, -1); revenue[0] = 0; for (int i = 1; i &lt;= length; i++) &#123; int q = -1; for (int j = 1; j &lt;= i; j++) &#123; q = max(q, price[j] + revenue[i - j]); &#125; revenue[i] = q; &#125; return revenue[length];&#125; 代码托管于github: scloudyy/CLRS 复杂度 时间复杂度: \(T(n) = \Theta(n^2)\) 重构解 动态规模只得到了最优解的值，但是没有得到真正的解：最优切割时子钢管的长度。可以通过扩展动态规划算法，使其同时保存最优切割时的切割长度，以此获得真正的最优解。 伪代码 1234567891011121314151617EXTENDED-BOTTOM-UP-CUT-ROD(p, n) let r[0,n] and s[0,n] to be a new array r[0] = 0 for i = 1 to n q = -MAX for j = 1 to n if q &lt; p[j] + r[i - j] q = p[j] + r[i - j] s[i] = j r[i] = q return r and sPRINT-CUT-ROD-SOLUTION(p, n) [r, s] = EXTENDED-BOTTOM-UP-CUT-ROD(p, n) while n &gt; 0 print s[n] // 打印钢管长度为n时最佳分割点 n = n - s[n] // n减去最佳分割长度，继续打印剩下的子钢管的最佳分割长度 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;tuple&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;using ret_type = tuple&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt;;ret_type extended_bottom_up_cut_rod(const vector&lt;int&gt; price, const int length) &#123; vector&lt;int&gt; revenue(length + 1, -1); vector&lt;int&gt; piece(length + 1, -1); revenue[0] = 0; piece[0] = 0; for (int i = 1; i &lt;= length; i++) &#123; int q = -1; for (int j = 1; j &lt;= i; j++) &#123; if (q &lt; price[j] + revenue[i - j]) &#123; q = price[j] + revenue[i - j]; piece[i] = j; &#125; &#125; revenue[i] = q; &#125; return make_tuple(revenue, piece);&#125;void print_cut_rod_solution(const vector&lt;int&gt; price, const int length) &#123; vector&lt;int&gt; revenue; vector&lt;int&gt; piece; tie(revenue, piece) = extended_bottom_up_cut_rod(price, length); int n = length; cout &lt;&lt; "optimal revenue: " &lt;&lt; revenue[length] &lt;&lt; endl; cout &lt;&lt; "optimal piece: "; while (n &gt; 0) &#123; cout &lt;&lt; piece[n] &lt;&lt; " "; n -= piece[n]; &#125;&#125;int main(int argc, char **argv) &#123; vector&lt;int&gt; rod_price&#123;0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30&#125;; print_cut_rod_solution(rod_price, rod_price.size() - 1);&#125; 代码托管于github: scloudyy/CLRS [参考资料] Introduction to Algorithms]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dynamic programming</tag>
        <tag>CLRS</tag>
        <tag>rod cutting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划 Dynamic Programming]]></title>
    <url>%2Fposts%2Fa0592a72%2F</url>
    <content type="text"><![CDATA[与归并算法的区别 动态规划和与分治法一样也是通过合并子问题来得到原问题的解，但是与分治法将原文题分解为不重叠的子问题不同，动态规划的子问题是相互重叠的。在这个角度上，动态规划是存在冗余计算的（重复求解共同的子问题），所以动态规划算法会将求解得到的子问题的结果存储在一张表中以避免对相同问题的重复计算 动态规划的英文为dynamic programming。programming在这里的意义就是一种“表格方法 - tabular method”， 而存储在表中的内容是动态变化的，在递归的过程中逐步更新表中的数据，所以称为dynamic programming 使用场景及特征 经常在优化问题中使用动态规划。优化问题指该问题可能有多个解，每种解都有一个值，希望找到值最小或最大的解 如果优化问题存在以下两个特征，则一般标志着应该使用动态规划： 优化问题存在最优子结构 如果一个问题的最优解包含了子问题的最优解，那么这个问题存在最优子结构 问题的解需要做出决策（如钢管分割中的“第一刀”），这个决策会将问题分为一个或多个待解决的子问题。而在解决问题时，我们一般会先假定这些决策是已知的。 原文题最优解所使用的子问题的解必须本身也是最优解（cuta and paste） 子问题重叠 在递归求解子问题时，相同子问题在递归树中出现多次。子问题重叠，使用表方法记录结果避免重复计算 一般步骤 动态规划一般遵循的四个步骤： 描述最优解的结构 根据最优解与子问题最优解之间的关系，使用递归定义最优解 自下向上计算最优解的值与最优决策 通过计算结果构造最优解（第三步只存储了决策，使用决策构造最优解） 动态规划的两种实现方式 带存储的自顶向下方法 自顶向下的递归方法更容易直观的理解：从输入的原始问题开始逐层分解。同时，为了避免子问题的重复求解，将每一个子问题的解存储在数组或哈希表中。程序首先会查看表中是否存在该规模的子问题的解，如果存在则直接取值，否则计算子问题并保存结果。 自底向上方法 从规模最小的子问题开始求解。当求解到规模为n的子问题时，规模小于n的子问题的最优解已经全部得到求解并被保存 自底向上的方法往往比带存储自顶向下的方法快常数因子，因为其不需要递归。但是对于某些子问题不需要全部被求解的问题，自顶向下的方法会更有优势，因为其不会求解必须要求解的子问题 [参考资料] Introduction to Algorithms https://blog.csdn.net/crazyboy2005/article/details/2673357]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dynamic programming</tag>
        <tag>CLRS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排 Quick Sort]]></title>
    <url>%2Fposts%2F8eb16336%2F</url>
    <content type="text"><![CDATA[算法思想 分治思想: 分解： 将数组A[p,r]分为两个（可能为空）子数组A[p,q-1]与A[q+1,r]，使得A[p,q-1]中的每个元素小于等于A[q]与A[q+1,r] 解决： 使用快排递归地对子数组A[p,q-1]与A[q+1,r]进行排序 合并： 不需要合并，整个数组已经有序 注意！Quick Sort中pivot不能进入递归！ 伪代码 12345QUICKSORT(A, p, r) if p &lt; r q = PARTITION(A, p, r) QUICKSORT(A, p, q - 1) QUICKSORT(A, q + 1, r) 123456789PARTITION(A, p, r) x = A[r] i = p - 1 for j = p to r -1 if A[j] &lt; x i = i + 1 exchange A[i] with A[j] exchange A[i + 1] with A[r] return i + 1 PARTITION会选择元素x = A[r]作为pivot来分割数组 PARTITION的循环不变性： 每次循环开始前，每个元素k只属于以下四类（可能有空类）： 如果 p &lt;= k &lt;= i，则A[k] &lt; x 如果 i + 1 &lt;= k &lt;= j - 1, 那么A[k] &gt; x 如果 j &lt;= k &lt;= r - 1, 那么该元素还没有被分类，与x没有关系 如果 k = r，那么A[k] = x 实现 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;using it_int = vector&lt;int&gt;::iterator;it_int partition(it_int begin, it_int end) &#123; if (end - begin &lt;= 1) &#123; return begin; &#125; auto x = *(end - 1); auto i = begin; for (auto j = begin; j != end - 1; j++) &#123; if (*j &lt; x) &#123; auto tmp = *j; *j = *i; *i = tmp; i++; &#125; &#125; auto tmp = *i; *i = *(end - 1); *(end - 1) = tmp; return i;&#125;void quick_sort(it_int begin, it_int end) &#123; if (end - begin &gt; 1) &#123; auto mid = partition(begin, end); quick_sort(begin, mid); quick_sort(mid + 1, end); &#125;&#125;int main (int argc, char **argv) &#123; vector&lt;int&gt; arr&#123;1, 5, 2, -4, 10, 20, -7, 0, 0, 1, 2&#125;; quick_sort(arr.begin(), arr.end()); for (auto i : arr) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125;&#125; 代码托管于github: scloudyy/CLRS 复杂度 时间复杂度： Worst: \(\Theta(n^2)\) on Average: \(\Theta(nlgn)\) 快排的效率只要取决于数组是否平衡，即pivot能否将数组大体平分。在最坏的情况下，pivot将A[n]分类A[n-1]与A[0]两个子数组，在这种情况下，其复杂度接近插入排序；如果pivot能够将数组A较号的分割，其复杂度接近归并排序。 随机快排 虽然我们不能假设所有的输入数组内的元素排列都是平衡的，但是可以在算法中引入随机性来打破可能存在的不平衡，从而算法从平均结果来看能够对所有输入都达到理想的复杂度。 在快排的随机化中，我们使用从数组A中随机挑选的元素作为pivot分割数组，使得平均来看，数组能够被平衡地分割。 伪代码 12345RANDOMIZED-QUICKSORT(A, p, r) if p &lt; r q = RANDOMIZED-PARTITION(A, p, r) RANDOMIZED-QUICKSORT(A, p, q - 1) RANDOMIZED-QUICKSORT(A, q + 1, r) 1234RANDOMIZED-PARTITION(A, p, r) i = RANDOM(p, r) exchange A[r] with A[i] return PARTITION(A, p, r) [参考资料] Introduction to Algorithms https://commons.wikimedia.org/wiki/File:Quicksort-example.gif]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>CLRS</tag>
        <tag>sort</tag>
        <tag>quick sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序 Heap Sort]]></title>
    <url>%2Fposts%2F26e60590%2F</url>
    <content type="text"><![CDATA[算法思想 将输入的数组构建为一个最大堆并使用最大堆的特性进行排序。由于在最大堆中最大的元素始终位于二叉树的root，所以我们可以安心的将最大的第一个元素与二叉树最后一个叶节点，使得最大的元素处于数组中合理位置，并维护最大堆。重复此步骤知道所有元素都处于合理位置。 最大堆的构建与维护 堆通常使用完全二叉树的数据结构来表示，存储方式为数组。最大堆是指节点的值始终大于等于其子节点的值，所以在最大堆中值最大的元素始终位于root的位置。 1A[PARENT(i)] &gt;= A[i] 在数组中最大堆子节点与父节点之间index的关系为： 12345678PARENT(i) // 返回节点i的父节点的index return floor(i/2)LEFT(i) // 返回节点i左子节点的index return 2iRIGHT(i) // 返回节点i右子节点的index return 2i + 1 维护堆的性质 假设以节点i的左右子节点为root的完全二叉树都满足最大堆的性质，但是节点i的值可能小于左右子节点的值，这与最大堆性质不符，需要将节点i“下沉”到合理位置： 将节点i的值与左右子节点比较，如果节点i不知最大的，则将节点i与三个节点中最大的那个互换位置，然后对更换位置后的节点"i"重复执行上述操作。 123456789101112MAX-HEAPIFY(A, i) l = LEFT(i) r = RIGHT(i) if l &lt;= A.heap-size &amp;&amp; A[i] &lt; A[l] largest = l else largest = i if r &lt;= A.heap-size &amp;&amp; A[largest] &lt; A[r] largest = r if i != largest exchange A[i] width A[largest] MAX-HEAPIFY(A, largest) 时间复杂度： \(O(lgn)\) 创建一个最大堆 根据最大堆的存储数组中父子节点index的规律，可以知道二叉树的root时数组第一个元素，数组越靠前离root越近，数组后半部分全是叶节点：A[(floor(n/2)+1)..n]。根据这一特性，我们可以从最后一个节点（最后一个节点的左右子节点都是叶子，叶子由于其只有单个元素所以符合最大堆的性质）开始从后往前对每一个节点进行维护堆性质的操作，直到左右节点满足最大堆性质，最大堆构建完成。 1234BUILD-MAX-HEAP(A) A.heap-size = A.length for i = fllor(A.heap-size/2) downto 1 MAX_HEAPIFY(A, i) 循环不变性：每次循环前，每个i+1, i+2,...n节点都是一个最大堆的根 时间复杂度： \(O(n)\) 堆排序伪代码与实现 伪代码 123456HEAPSORT(A) BUILD-MAX-HEAP(A) for i = A.length to 2 exchange A[1] with A[i] A.heap-size = A.heap-size - 1 MAX-HEAPIFY(A, 1) 最终实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;class HeapSort &#123;public: HeapSort(vector&lt;int&gt;::iterator begin, vector&lt;int&gt;::iterator end) &#123; _heap_root = begin; _heap_size = end - begin; _build_max_heap(); &#125; void heap_sort(void) &#123; for (auto i = _heap_size - 1; i &gt;= 1; i--) &#123; auto tmp = *(_heap_root); *(_heap_root) = *(_heap_root + i); *(_heap_root + i) = tmp; _heap_size--; _max_heapify(0); &#125; &#125;protected: size_t _get_parent(size_t i) &#123; return floor((i + 1) / 2) - 1; &#125; size_t _get_left(size_t i) &#123; return (i + 1) * 2 - 1; &#125; size_t _get_right(size_t i) &#123; return (i + 1) * 2; &#125; void _max_heapify(size_t i) &#123; if (i &gt;= _heap_size) &#123; return; &#125; size_t l = _get_left(i); size_t r = _get_right(i); size_t largest = i; if (l &lt; _heap_size &amp;&amp; *(_heap_root + i) &lt; *(_heap_root + l)) &#123; largest = l; &#125; if (r &lt; _heap_size &amp;&amp; *(_heap_root + largest) &lt; *(_heap_root + r)) &#123; largest = r; &#125; if (largest != i) &#123; auto tmp = *(_heap_root + i); *(_heap_root + i) = *(_heap_root + largest); *(_heap_root + largest) = tmp; _max_heapify(largest); &#125; &#125; void _build_max_heap(void) &#123; for (auto i = floor(_heap_size / 2) - 1; i &gt;= 0; i--) &#123; _max_heapify(i); &#125; &#125;private: vector&lt;int&gt;::iterator _heap_root; size_t _heap_size;&#125;;int main(int argc, char **arhv) &#123; vector&lt;int&gt; arr&#123;11, 3, 1, 4, 10, -2, 7, 10, 1&#125;; HeapSort heap_sort(arr.begin(), arr.end()); heap_sort.heap_sort(); for (auto i : arr) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125;&#125; 代码托管于github: scloudyy/CLRS 堆排序复杂度 时间复杂度: \(O(nlgn)\) 空间复杂度：原地排序(in place) [参考资料] Introduction to Algorithms https://commons.wikimedia.org/wiki/File:Heapsort-example.gif]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>CLRS</tag>
        <tag>heap sort</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的size_t]]></title>
    <url>%2Fposts%2F8dccde94%2F</url>
    <content type="text"><![CDATA[C++标准库如vector, string等都定义了配套的类型，比如计算vector的size时，其返回的参数类型就是siez_t。 size_t存在于std命名空间中，被定义为与unsigned型。 size_t的存在是为了将标准库设计成与平台无关。一方面，如果使用int等类型来存放定义的string的size，一旦size超出int的范围，就会导致内存溢出，程序崩溃；另一方面，在不同平台上数据类型能够表示的范围是不一样的，例如32位和64位平台上int的范围就不同，这可能会导致程序在平台A可以成功运行，但到了平台B就崩溃。 size_t就是为了街上上述两个问题而被引入的：一个与机器无关的unsigned类型，并且其大小足以保证存储内存中对象的大小。所以，保存对象的size的最安全的方法就是使用标准库类型std::size_t，并且其能够保证在不同平台的一致表现。]]></content>
      <categories>
        <category>technology</category>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>size_t</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子数组 Maximum Subarray]]></title>
    <url>%2Fposts%2F4ffc25c9%2F</url>
    <content type="text"><![CDATA[问题描述 算法目标：在连续数组中寻找拥有最大和的子数组 只有数组中正负值皆有问题才有意义，如果都是正值则整个数组的和最大 最大子数组可能不止一个 算法思想1 - 分治法 将数组等分为两个子数组L与R，则最大子数组只存在三种情况： 完全位于子数组L 完全位于子数组R 跨越中点mid，同时包含L, R中靠近mid的部分 分解： 将数组A[1,n]平均分为两个子数组L[1, n/2], R[n/2+1, n] 解决： 递归求解子数组L，R的最大子数组 合并： 求解跨越中点mid的最大子数组（这一步并不是原问题的较小实例，所以算在合并中），并返回三种情况中最大的子数组 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;vector&gt;#include &lt;limits&gt;#include &lt;tuple&gt;#include &lt;iostream&gt;using namespace std;const int MIN = numeric_limits&lt;int&gt;::min();using return_type = tuple&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator, int&gt;;return_type find_max_crossing_subarray (vector&lt;int&gt;::iterator left, vector&lt;int&gt;::iterator mid, vector&lt;int&gt;::iterator right) &#123; int right_max = 0, left_max = 0, sum = 0; auto p_r = mid, p_rmax = mid; for (; p_r != right; p_r++) &#123; sum += *p_r; if (sum &gt; right_max) &#123; right_max = sum; p_rmax = p_r; &#125; &#125; sum = 0; auto p_l = mid - 1, p_lmax = mid; //for (; p_l != left - 1; p_l--) &#123;&#125; // 这里不能用p_l != left - 1，虽然从右往左使用begin() != end()，end()指向数组后一个元素，但是从右向左时不能人为超出数组边界 for (; p_l &gt;= left; p_l--) &#123; sum += *p_l; if (sum &gt; left_max) &#123; left_max = sum; p_lmax = p_l; &#125; if (p_l == left) &#123; break; // 这里要加上break，否则循环体结束会执行p_l--，此时迭代器超出容器范围 &#125; &#125; return make_tuple(p_lmax, p_rmax + 1, right_max + left_max); // p_rmax + 1是为了保持迭代器一致性：最右侧迭代器始终指向最后一个元素的后一个位置&#125;return_type find_maximum_subarray(vector&lt;int&gt;::iterator left, vector&lt;int&gt;::iterator right) &#123; if ((right - left) &lt;= 1) &#123; return make_tuple(left, right, *(left)); &#125; else &#123; auto mid = left + (right - left) / 2; auto res_left = find_maximum_subarray(left, mid); auto res_right = find_maximum_subarray(mid, right); auto res_mid = find_max_crossing_subarray(left, mid, right); auto v_left = get&lt;2&gt;(res_left); auto v_right = get&lt;2&gt;(res_right); auto v_mid = get&lt;2&gt;(res_mid); if (v_left &gt;= v_right &amp;&amp; v_left &gt;= v_mid) &#123; return res_left; &#125; else if (v_right &gt;= v_left &amp;&amp; v_right &gt;= v_mid) &#123; return res_right; &#125; else &#123; return res_mid; &#125; &#125;&#125;int main(int argc, char **argv) &#123; vector&lt;int&gt; arr&#123;2, -1, 5, 6, -2, 7, -3, 9, -8&#125;; auto res = find_maximum_subarray(arr.begin(), arr.end()); tuple_element&lt;0, decltype(res)&gt;::type left; tuple_element&lt;1, decltype(res)&gt;::type right; tuple_element&lt;2, decltype(res)&gt;::type value; tie(left, right, value) = res; for (; left != right; left++) &#123; cout &lt;&lt; *left &lt;&lt; " "; &#125; cout &lt;&lt; "max value = " &lt;&lt; value &lt;&lt; endl;&#125; 代码托管于github: scloudyy/CLRS 复杂度 时间复杂度: \(T(n) = nT(2/2) + \Theta(n) = \Theta(nlg(n))\) 算法思想2 前提：最大子数组的起始元素一定是正数（否则降低一个元素剔除，剩余的子数组和会更大） 每当累加和小于零时，从下一个元素重新开始累加 实现 123456789101112131415161718return_type find_maximum_subarray2(vector&lt;int&gt;::iterator left, vector&lt;int&gt;::iterator right) &#123; auto p_l = left, p_lmax = left, p_rmax = left; int max_val = 0, cur_val = 0; for (; left != right; left++) &#123; cur_val += *left; if (cur_val &lt;= 0) &#123; // 将当前和看作一个整体，如果第一个元素小于零，则从下一个元素开始重新累加 p_l = left + 1; cur_val = 0; &#125; if (cur_val &gt; max_val) &#123; max_val = cur_val; p_rmax = left; p_lmax = p_l; &#125; &#125; return make_tuple(p_lmax, p_rmax + 1, max_val); // p_rmax + 1是为了保持迭代器一致性：最右侧迭代器始终指向最后一个元素的后一个位置&#125; 代码托管于github: scloudyy/CLRS 复杂度 时间复杂度: \(\Theta(n)\) [参考资料] Introduction to Algorithms]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>CLRS</tag>
        <tag>maximum subarray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序 Merge Sort]]></title>
    <url>%2Fposts%2F8f40f65f%2F</url>
    <content type="text"><![CDATA[算法思想 分治思想 分解： 将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 解决： 若子问题规模足够小则直接解决，否则递归解决子问题 合并： 将各个子问题的解合并为原问题的解 归并排序 分解： 将数组A[1,n]平均分为两个子数组L[1, n/2], R[n/2+1, n] 解决： 如果数组元素个数只有1，则已有序，否则继续递归 合并： 从左到右依次取L, R中的较小的元素，放到A中 伪代码 123456789101112131415161718192021222324252627282930merge(A, p, q, r) n1 = q - p + 1 // 子数组L的元素个数，L包含q n2 = r - q // 子数组R的元素个数，R不包含q // 将数组A的内容分别拷贝至子数组L，R for i = 1 to n1 L[i] = A[p + i -1] for j = 1 to n2 R[j] = A(q + j) // 在L，R末尾放置sentinel L[i + 1] = MAX R[j + 1] = MAX i = 1 j = 1 // 从左到右依次取L, R中的较小的元素，放到A中 for k = p to r if L[i] &lt;= R[j] A[k] = L[i] i = i + 1 else A[k] = R[j] j = j + 1merge-sort(A, p, r) if q &lt; r q = floor((p + r) / 2) // 将数组A平均分为两个子数组L，R递归求解 merge-sort(A, p, q) merge-sort(A, q + 1, r) // 归并已有序的子数组L，R merge(A, p, q, r) 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;limits&gt;using namespace std;const int MAX = numeric_limits&lt;int&gt;::max();void merge(vector&lt;int&gt;::iterator left, vector&lt;int&gt;::iterator middle, vector&lt;int&gt;::iterator right) &#123; auto L_num = middle - left; auto R_num = right - middle; vector&lt;int&gt; L(left, middle); vector&lt;int&gt; R(middle, right); L.push_back(MAX); R.push_back(MAX); auto p_L = L.begin(); auto p_R = R.begin(); for (; left != right; left++) &#123; if(*p_L &lt; *p_R) &#123; *left = *p_L; p_L++; &#125; else &#123; *left = *p_R; p_R++; &#125; &#125;&#125;void merge_sort(vector&lt;int&gt;::iterator begin, vector&lt;int&gt;::iterator end) &#123; if (end - begin &gt; 1) &#123; auto middle = begin + (end - begin) / 2; merge_sort(begin, middle); merge_sort(middle, end); merge(begin, middle, end); &#125;&#125;int main(int argc, char **argv) &#123; vector&lt;int&gt; arr&#123;3, 2, 4, 7, 9, 10, -2, 11, 8, 1, 0&#125;; merge_sort(arr.begin(), arr.end());&#125; 代码托管于github: scloudyy/CLRS 复杂度 时间复杂度: \(\Theta(nlg(n))\) 空间复杂度: \(\Theta(n)\) [参考资料] Introduction to Algorithms https://commons.wikimedia.org/wiki/File:Merge-sort-example-300px.gif]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>CLRS</tag>
        <tag>sort</tag>
        <tag>merge sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序 Insertion Sort]]></title>
    <url>%2Fposts%2F34013598%2F</url>
    <content type="text"><![CDATA[算法思想 假设左侧子数组已经有序，将子数组后一位的元素值key从右向左与子数组中的元素比较，如果不合适则将子数组中元素后移一位，直至key找到并插入正确的位置，使得新子数组保持有序状态。接着新子数组后的key进行同样的操作。 伪代码 12345678910insertion-sort(A) for j = 2 to A.length key = A[j] // 将A[j]插入到A[1, j - 1] i = j - 1 while i &gt; 0 and key &lt; A[i] // 如果key仍然比A[i]小，则将A[i]右移一位 A[i + 1] = A[i] i = i - 1 A[i + 1] = key // key与i进行&lt;比较，如果跳出循环则key的位置在i右侧 循环不变性 对数组A进行排序，在每一次循环开始前，子数组A[1, j - 1]处于有序状态 初始：第一次循环开始前子数组为空，处于有序状态 维持：每次循环结束后j + 1，子数组A[1, j - 1]处于有序状态 终止：循环终止时j = n + 1， 将n + 1带入A[1, j - 1]，得到数组A[1, n]处于有序状态。整个数组排序完成，算法正确 实现 123456789101112131415void insertion_sort(vector&lt;int&gt; &amp;arr) &#123; int key; for (auto j = arr.begin() + 1; j != arr.end(); j++) &#123; key = *j; auto i = j - 1; while(i &gt;= arr.begin() &amp;&amp; key &lt; *i) &#123; *(i + 1) = *i; if (i == arr.begin()) &#123; break; &#125; i--; &#125; *(i + 1) = key; &#125;&#125; 代码托管于github: scloudyy/CLRS 复杂度 时间复杂度: \(\Theta(n^2)\) 空间复杂度: \(\Theta(1)\) [参考资料] Introduction to Algorithms https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif]]></content>
      <categories>
        <category>technology</category>
        <category>algorithm</category>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>CLRS</tag>
        <tag>sort</tag>
        <tag>insertion sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX数学公式]]></title>
    <url>%2Fposts%2F8f6abaad%2F</url>
    <content type="text"><![CDATA[希腊字母 \(\alpha\) : \alpha \(\beta\) : \beta \(\gamma\) : \gamma \(\delta\) : \delta \(\epsilon\) : \epsilon \(\zeta\) : \zeta \(\eta\) : \eta \(\theta\) : \theta \(\Theta\) : \Theta \(\iota\) : \iota \(\kappa\) : \kappa \(\lambda\) : \lambda \(\mu\) : \mu \(\nu\) : \nu \(\xi\) : \xi \(\omicron\) : \omicron \(\pi\) : \pi \(\rho\) : \rho \(\sigma\) : \sigma \(\Sigma\) : \Sigma \(\tau\) : \tau \(\upsilon\) : \upsilon \(\phi\) : \phi \(\Phi\) : \Phi \(\chi\) : \chi \(\psi\) : \psi \(\omega\) : \omega 符号 \(\sum_1^n\) : \sum_1^n \(\int_1^\infty\) : \int_1^\infty \(\prod\) : \prod \(\bigcup\) : \bigcup \(\bigcap\) : \bigcap \(\iint\) : \iint \(\frac{a}{b}\) : \frac{a}{b} \(\sqrt[4]{\frac xy}\) : \sqrt[4]{\frac xy} \(\lt \gt \le \ge \neq\) : \lt \gt \le \ge \neq \(\times \div \pm \mp\) : \times \div \pm \mp \(\hat{a}\) : \hat{a} \(\widehat{ab}\) : \widehat{ab} \(\overline{a}\) : \overline{a} \(\vec{a}\) : \vec{a} \(\overrightarrow{a}\) : \overrightarrow{a} \(\dot{a}\) : \dot{a} \(\ddot{a}\) : \ddot{a} \(\to\) : \to \(\gets\) : \gets \(\in\) : \in \(\notin\) : \notin \(\sim\) : \sim \(\cdots\) : \cdots 矩阵 begin{matrix}…\end{matrix} 行用\\分隔，列用&amp;分隔: \(\begin{matrix}1 &amp; 2\\ 3 &amp; 4 \end{matrix}\) : begin{matrix}1 &amp; 2\\ 3 &amp; 4 \end{matrix} 用其他符号替换matrix会有别的括号: \(\begin{pmatrix}1 &amp; 2\\ 3 &amp; 4 \end{pmatrix}\) : begin{pmatrix} \(\begin{bmatrix}1 &amp; 2\\ 3 &amp; 4 \end{bmatrix}\) : begin{bmatrix} \(\begin{Bmatrix}1 &amp; 2\\ 3 &amp; 4 \end{Bmatrix}\) : begin{Bmatrix} \(\begin{vmatrix}1 &amp; 2\\ 3 &amp; 4 \end{vmatrix}\) : begin{vmatrix} \(\begin{Vmatrix}1 &amp; 2\\ 3 &amp; 4 \end{Vmatrix}\) : begin{Vmatrix} \(\cdots \ddots \vdots\) : \cdots \ddots \vdots [参考资料] Online LaTex Equation Editor]]></content>
      <categories>
        <category>technology</category>
        <category>latex</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab基础]]></title>
    <url>%2Fposts%2F90c7cf91%2F</url>
    <content type="text"><![CDATA[行末加分号的语句不会输出，没有加分号的语句将会强制输出 []表示一个矩阵，每行用分号结束 12A1 = [1 2 3]; %行向量 A2 = [1; 2; 3]; %列向量 取元素 A(1, 2)取单个元素，A(1, 1:3)取出第二行 1 到 3 个元素， matlab 从 1 开始计数 同样，对行也可以用冒号这种形式，如果只有冒号表示取全部，行列最后是通道值。 12345678910111213141516171819202122232425262728293031A = [1 2 3; 4 5 6; 7 8 9]A(2, 2)% 5A(2, 2:3)% 5 6img = imread('1.bmp');a = img;img(:, 30, 1) = 0;img(:, 30, 2) = 0;img(:, 30, 3) = 255;figure;imshow(a);title('蓝线');% 复制 img 为 a，将 a 的第 30 列所有像素变为蓝色并显示b = img;img(:, :, 1) = 0;img(:, :, 2) = 0;img(:, :, 3) = 0;figure;imshow(a);title('黑图');imwrite(b, 'a.bmp');% 复制 img 为 b，并全图赋为黑色，显示并保存c = [b, img];% 将 img 矩阵附加到 b 矩阵后c = img(10:100, 20:200, 1:3);% 将 img 的第 10 到 100 行，第 20 到 200 列赋给 c 矩阵创建操作都用[]，矩阵取元素操作都用() 循环 for i = 起始值:步长:结束值 主体语句; end (包括结束值) 12345678910111213141516a = 0;for i = 2:2:10 a = a + i;endb = (2:2:10);% 2 4 6 8 10% 其实 起始值:步长:结束值 是一个行向量，即一行的矩阵% 循环更一般的表达式是 循环变量 = 矩阵表达式b = [1 2 3; 4 5 6; 7 8 9];a = 0;for i = b a = a + i;end% 貌似只取列向量。 条件判断 12345678a = 10;if a &lt; 10 flag = 0;elseif a == 10 flag = 1;else flag = 2;end 函数 matlab里自定义的函数都是以文件的形式，一个函数一个文件，当然函数文件里也能有子函数，但子函数只能在该文件内调用。 12345function [s, p] = fcircle(r)%%s = pi * r * r;p = 2 * pi * r; 文件名就叫 fcircle.m 传入的参数不会改变 matlab 搜索逻辑: 1.检查是不是变量 2.检查是不是内部函数 3.检查是不是当前目录下的 M 文件 4.检查是不是 matlab 搜索路径中其它目录下的 M 文件 要注意变量在 Workspace 中有没有存在。 常用内置函数 123src = im2double(imread('src.bmp'));[height, width, ~] = size(src);hsv = rgb2hsv(src); 数据类型转换 1234num2str(0.1);str2num('0.1');lab = rgb2lab(rgb);gray = rgb2gray(rgb); 代码分行 如果一句代码太长需要分行写，再分行处加上...，matlab会将用...连接的两行代码视为连贯的一句代码。 123data(count, 1) = (ori(i, j, 1) - obj(i, j, 1))^2 + ... (ori(i, j, 1) - obj(i, j, 1))^2 + ... (ori(i, j, 1) - obj(i, j, 1))^2 ; 计算图像边缘 12I=rgb2gray(I);BW1 = edge(I,'canny'); 点乘与叉乘 点乘结果是一个标量，又称内积 \(\vec{a}\cdot \vec{b}=\left | \vec{a} \right |\left | \vec{b} \right |cos\theta\) 12345678910111213A = [1 2 3];B = [3 2 1];dot(A,B); % 点乘% 根据点乘的几何意义可以求出两向量夹角的 cos 值，norm()求向量的长度cosTheta = dot(A,B)/norm(A)/norm(B);theta = acos(cosTheta);% 只要向量(矩阵)内的元素两两相乘C = A.*B;dot(A,B) = sum(A.*B);% sum()只将列元素相加，如果想得到矩阵所有元素相加的结果sum(sum(A)); 向量叉乘结果仍然是向量,叉积垂直于两向量所在的平面 1cross(A,B); 文件操作 12345f = fopen('file.txt', 'w');fprintf(f, '%f \n', 0.1);% data = fscanf(fid,format,size);data = fscanf(f,'%f %f', [2, inf]);% 其中data为读取内容的数组，它的大小由size决定，即如果size为[2,3]，data即为2行3列，如果size为[4 inf]，则data为4行n列，而且data数据先按列填满4个，之后再换一列。size是一个[m n]的向量 'r' 只读，文件必须存在（缺省的打开方式） 'w' 写文件，若文件已存在则原内容将被覆盖；若文件不存在则新建一个 'a' 在文件末尾添加，文件若不存在则新建一个 'r+' 可读可写，文件必须存在 'w+' 可读可写，若文件已存在则原内容将被覆盖；若文件不存在则新建一个 'a+' 可读可写可添加，文件若不存在则新建一个 读取一个文件夹中的图像 12345678910111213fileFolder=fullfile('E:\file');dirOutput=dir(fullfile(fileFolder,'*'));fileNames=&#123;dirOutput.name&#125;;for i = 1:1:length(fileNames) if sum(strfind(char(fileNames(i)), 'bmp')) || sum(strfind(char(fileNames(i)), 'jpg')) || sum(strfind(char(fileNames(i)), 'png')) % 加上 sum 因为没有这个文件的话返回的是[]，要把它转为数值 img = imread(char(strcat('img\', fileNames(i)))); hsv = rgb2hsv(img); v = hsv(:,:,3); imwrite(v, char(strcat('HSV\', fileNames(i), '_HSV.bmp'))); endend 结构体 1234567891011121314151617181920% 统一赋值s1 = sturct('field1',values1,'field2',values2);% 直接赋值s2.field1 = values1;s2.field2 = values2;% 删除属性s1 = refield(s1, 'field2');% 通过fieldnames()来获取所有字段的名称fieldnames(s2);ans = 'field1' 'field2'% 通过isfield()来判断是否存在某一字段isfield(s2, 'field3')ans = 0 排序 123456789101112131415a=[5 7 8; 4 6 1; 8 0 7]a = 5 7 8 4 6 1 8 0 7&gt;&gt; sortrows(a,3)ans = 4 6 1 8 0 7 5 7 8sort(A,'descend') % 一维 求解大型方程组 X = bicg(A,B) attempts to solve the system of linear equations A*X=B for X. sparse(m,n) Create sparse matrix. 123456i = [1 2];j = [1 2];s = [2 2];A = sparse(i, j, s, 2, 2);B = [1; 1];X = bicg(A, B); 随机数 rand([m n]) 产生 m 行, n 列 (0，1) 范围内均匀分布的伪随机数 如果要求在区间 (a,b) 内产生 mn 个均匀分布的随机数: r = a + (b-a).rand([m n]); 生成一个: r = a + (b-a).*rand([1, 1]); 命令行打印 12str = sprintf('line: %d', i);disp(str); Tips Ctrl+R 注释 Ctrl+T 取消注释]]></content>
      <categories>
        <category>technology</category>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python图像处理 - Pillow的基本使用]]></title>
    <url>%2Fposts%2F33a544be%2F</url>
    <content type="text"><![CDATA[History PIL在python2.x是停止更新，于是在python3.x时出现了pillow。import的时候仍然要用PIL来代替Pillow Usage 12345678910111213# !/usr/bin/python# -*- coding:utf-8 -*-from PIL import Imagefrom numpy import *pil_img = Image.open('D:\\1.tif')# 加载图像（路径必须双\\）pil_img.show()# 显示img = array(pil_img)# 转化为数组height,width = img.shape[0:2]# 获取图像参数value = img[i,j,k] #访问像素[行，列，channel]pil_im2 = Image.fromarray(uint8(img))#转回PILpil_img.save('D:\\2.tif')# 另存为]]></content>
      <categories>
        <category>technology</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pillow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像空间滤波方法]]></title>
    <url>%2Fposts%2Ff98cebdd%2F</url>
    <content type="text"><![CDATA[图像是由具有不同颜色值的像素点组成的，这堆数据可以被当作信号来处理，所以信号处理领域的滤波概念就被引到了图像处理界，指接受或拒绝一定的频率分量，用来滤去异常的信号。简单的例子就是去噪，比如在黑暗环境中拍摄的图像，经过放大后容易发现一个个黑色的孤立像素点，这些像素点就是噪点，异常的信号，也称噪声，滤波就是用来把这个噪声给滤掉。 滤波与去噪的关系理解为手段与目的的关系，滤波是手段，去噪是目的，滤波这个手段也可以做其他事情，去噪这个目的也可以用其他手段来达成，当然最常用的就是滤波。 那么什么叫图像上的空间滤波呢，这里的“空间”指的是像素点之间的距离，如像素点 x1 的坐标是 (1,1)，像素点 x2 的坐标是 (2,2)，那么它们的距离就是 \(\sqrt{(1-2)^2+(1-2)^2}=\sqrt{2}\) 。以像素点之间的距离为依据进行滤波的方法就是空间滤波。 卷积 在介绍几种主要的空间滤波方法前我们还要来简单了解一下卷积这个概念。卷积是两个函数 \(f\) 和 \(g\) 生成第三个函数的一种数学算子。在图像处理中，一个函数就是我们要处理的图像 \(f(x,y)\)，\(x\), \(y\) 分别是横纵坐标，另一个函数 \(g\) 就是滤波时使用的核，一般是一个 \(3*3\) 或 \(5*5\) 的块。例如当 \(g\) 这个小块的中心对应图像 \(f\) 的 (5,5) 位置的像素， 则 (5,5) 的像素的新的值为 \(g\) 内所有元素的值与此时 \(f\) 中对应元素值相乘再累加的结果，当 (5,5) 的到新的值后再将 \(g\) 移到 \(f\) 中下一个位置 (5,6)，以此循环图像 \(f\) 所有像素得到新的值。卷积的过程就像是用一把小刷子刷过图像，不同的刷子的材质纹理不同，刷完后的图像也具有各自不同面貌。 均值滤波 均值滤波很容易理解，当前的像素值使用周围像素值的均值来替换。为什么要这么滤波呢，这是因为噪点一般只有单个像素，当用周围像素值的均值来表示后，本来的黑色就会变得和周围的颜色基本一致，而周围的颜色也不会被黑色影响，因为单个突兀的像素影响力很小。 均值滤波的滤波核 \(g\) 也很容易得到，以 3 * 3 的核为例， 先将 \(g\) 内每个分量赋为1再做一步归一化就得到了均值滤波的滤波核(归一化指使所有分量累加等于一且各分量比例不变) \[ g(x,y) = \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \end{bmatrix} = \begin{bmatrix} \frac{1}{9} &amp; \frac{1}{9} &amp; \frac{1}{9} \\\\ \frac{1}{9} &amp; \frac{1}{9} &amp; \frac{1}{9} \\\\ \frac{1}{9} &amp; \frac{1}{9} &amp; \frac{1}{9} \end{bmatrix} \] 使用核 \(g(x,y)\) “扫”(卷积)一遍图像 \(f(x,y)\) 就是均值滤波。 高斯滤波 高斯滤波使用高斯函数对图像进行平滑 \[h(x,y)=e^{- \frac{x^2+y^2}{2\sigma ^2}}\] \(\sigma\) 是标准差，二维高斯函数具有钟形形状，标准差控制其紧度，\(\sigma\) 越小高斯函数越紧凑。将高斯函数应用到核函数 \(g\) 时， 高斯函数 \(h(x,y)\) 的 x,y 代表当前分量到中心点的距离，以 3 * 3 的核为例， 坐标 (2,2) 的分量就是这个核的中心，x,y 轴距离中心都为 0，所以坐标 (2,2) 核函数的值为 \(g(2,2) = h(0,0)\) ，又如坐标 (2,1) 的 x,y 距中心分别为 0,1 所以其值 \(g(2,1)=h(0,1)\)，所有值得到后再归一化就得到了高斯滤波的卷积核。使用这个核对图像做卷积就是高斯滤波。 高斯滤波与均值滤波的区别在哪呢？均值滤波只是单纯取平均值，周围像素对中心像素的影响力是一样的，而高斯函数对距中心不同距离的像素赋以不同的权重，中心像素权重最高，距离越远权重越低。不难想象，当卷积核处于图像边缘时，均值滤波会使边缘模糊，而高斯滤波由于有距离的约束，模糊现象会得到改善。 中值滤波 中值滤波是非线性的，它没有固定的核函数，是一种基于统计排序的滤波器。顾名思义，中值滤波就是对邻域中的像素进行排序，用中值代替中心像素的值，非常好理解。中值滤波比起均值滤波更适用于去除椒盐噪声，均值滤波会模糊边界且噪声去除效果也不是很好，相比起来中值滤波优势会很明显。]]></content>
      <categories>
        <category>technology</category>
        <category>computer vision</category>
      </categories>
      <tags>
        <tag>computer vision</tag>
        <tag>filter</tag>
        <tag>image process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6中class的用法]]></title>
    <url>%2Fposts%2F878930e4%2F</url>
    <content type="text"><![CDATA[ES6中的class其实是ES5中对类的一次封装，使写法更自然 用法很简单 123456789class A &#123; constructor(name) &#123; this.name = name; &#125; priuntName() &#123; console.log(this.name); &#125;&#125; 使用class声明一个类，类里直接写构造函数constructor用于初始化属性，接下来写方法，不需要逗号隔开 123456789101112131415161718class B extends A &#123; constructor(name, birth) &#123; super(name); this.birth = birth; &#125; printBirth() &#123; console.log(this.birth); &#125;&#125;class C extends B &#123; constructor(...args) &#123; super(...args); &#125;&#125;var b = new B(); 继承使用extends关键字，在子类的constructor里必须使用super来获取父类的this]]></content>
      <categories>
        <category>technology</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的prototype]]></title>
    <url>%2Fposts%2Fc2d8b909%2F</url>
    <content type="text"><![CDATA[prototype 相当于数据(属性及方法)的存储场，将来继承的就是这片存储场(也就是说这片场地位于原型链上); __proto__是真正的链接(就代表自身)，指向上一级的 prototype 。换句话说， prototype 里是子类要来继承的东西， __proto__ 指向本身继承自父类的东西。 实例化 1234567891011121314151617var Student = function(name) &#123; this.name = name;&#125;;Student.prototype.printName = function() &#123; console.log(this.name);&#125;;var stu1 = new Student('Peter');var stu2 = new Student('Tom');stu1.printName();stu2.printName();console.log(stu1.__proto__ == Student.prototype); // trueconsole.log(Student.prototype.constructor == Student); // trueconsole.log(stu1.constructor == Student.prototype.constructor); // true 类既有私有的属性又有公共的属性/方法。比如 Student 这个类里 name 这个属性，不同的实例存储有不同的 name 值，当执行 var stu1 = new Student('Peter') 时，构造函数将 stu1 作为构造函数里的 this 进行复制，即执行了 stu1.name = 'Peter' 。然而 printName() 这个方法不同的实例都是一样的，如果仍然使用前述的 this.printName = function(){} , 则每一个实例都存储了重复的内容消耗大量内存，于是js就把这些方法放到原型 prototype 中，每个实例连接到相同的原型，达到共享相同方法的目的。 实例化时将 stu1 的 __proto__ 指向 Student.prototype ( __proto__ 代表自身，相当于自己的一根连接线， prototype 只有函数有，是构造函数的一个仓库，里面放着共享的方法)。Student.prototype 里有构造函数，直接指向 student 自己，到时候用来赋 name 这些私有属性。这样一来，实例stu1只要用一个____proto____就既获取了构造函数又获取了方法。 类的继承 类继承时既要继承构造函数用来赋值私有属性，又要继承原型 prototype 用来共享公共方法。 1234567891011121314151617181920212223242526var Student = function(name) &#123; this.name = name;&#125;;Student.prototype.printName = function() &#123; console.log(this.name);&#125;;var Academician = function(name, scholarship) &#123; Student.call(this, name); // 继承构造函数，也就是继承属性 this.scholarship = scholarship;&#125;;//Academician.prototype = new Student();Academician.prototype = Student.prototype; // 继承原型链， 也就是继承方法Academician.prototype.constructor = Academician; // 由于Academician.prototype直接继承了Student.prototype， //所以现在Academician.prototype.constructor指向了Student， //要把它调回来指向自己，不然前面继承构造函数就白做了Academician.prototype.printScholarship = function() &#123; // 再为Academician添加一个方法 console.log(this.scholarship);&#125;;var stu3 = new Academician('Jon', 1000);stu3.printName();stu3.printScholarship(); 第10行的作用是继承基类的属性，方法就是在 Academician 的构造函数内使用 Academician 自己的 this 指针调用 Student 的构造方法。 第15和第16行用于继承基类的方法。第15行将 Academician 的 prototype 指向 Student 的 prototype ，16行修正了 Academician 的构造方法也指向了 Student 这一错误。 ES6中的继承 前面使用ES5实现继承比较麻烦，构造函数和原型链的继承要分开单独写。ES6中的 class 和 extends 直接帮你在下面做好了这样的事，简洁明了 123456789101112131415161718class A &#123;&#125;class B extends A &#123;&#125;var b = new B();console.log(B.__proto__ === A); // trueconsole.log(B.prototype.__proto__ === A.prototype); // trueconsole.log(b.__proto__ === B.prototype); // trueconsole.log(B.prototype.constructor === B); // trueconsole.log(b.constructor === B.prototype.constructor); // trueconsole.log(b.constructor === B); // trueconsole.log(b.constructor === b.__proto__.constructor); // trueconsole.log('b.__proto__:', b.__proto__); // b.__proto__: B &#123;&#125;console.log('b.prototype:', b.prototype); // b.prototype: undefinedconsole.log('b.constructor:', b.constructor); // b.constructor: class B extends A &#123;&#125;]]></content>
      <categories>
        <category>technology</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab中的sparse函数]]></title>
    <url>%2Fposts%2F465acdd6%2F</url>
    <content type="text"><![CDATA[记一次Matlab处理大型系数矩阵过程中的探索 创建一个系数矩阵有很多方法，最简单的如： 1A = sparse(1000, 1000) 这会创建一个1000*1000的系数矩阵，虽然很大，其实没有占什么内存，因为稀疏矩阵只会存储非零的值，刚创建的稀疏矩阵没有存储任何值，默认全为零。 赋值时可以按普通矩阵的方法赋值 1A(1,1) = 2 讲稀疏矩阵的第一行第一列赋值为2 但如果要往稀疏矩阵里放很多值，不推荐以上做法，因为稀疏矩阵内部是类似链表的实现，一次赋值太多速度会非常慢，我之前忘稀疏矩阵里添加大约十万个值发现一个下午都不一定能跑完 如果要往系数矩阵里赋大量的值，正确的做法应该是这样的。 将元素的行坐标，列坐标，还有元素的值分别存入三个向量中，三个向量中各个分量一一对应，然后使用sparse(i, j, k, m, n)一次性创建，i,j,k分别是行坐标向量，列坐标向量，值向量，m,n是系数矩阵的行宽。如 1234i = [1, 2]j = [3, 4]k = [5, 6]A = sparse(i, j, k, 1000, 1000) 以上代码创建了一个1000*1000的稀疏矩阵，里面存了两个值，第1行第3列值为5，第2行第4列值为6。 这种创建方法虽然没有第一种来的直观，但由于值是先写到普通的向量里面，速度比较块一般几十万的数据十分钟也能搞定，然后通过数组创建sparse矩阵，Matlab肯定经过专门的优化，这一步不超过十秒钟。相比之前需要一整个下午不可同日而语。]]></content>
      <categories>
        <category>technology</category>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
</search>
